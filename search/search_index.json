{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Agentic Flows","text":"<p>A deterministic, contract-first execution and replay framework \u2014 strict invariants, reproducible runs, and traceable outputs. Build audit-ready agent workflows with stable artifacts and replayable traces.</p> <p> </p> <p>At a glance: deterministic execution \u2022 invariant enforcement \u2022 replayable traces \u2022 CLI surface \u2022 API schema only \u2022 structured telemetry Quality: coverage floors enforced per module, benchmark regression gate active, docs linted and built in CI, no telemetry.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Why Agentic Flows?</li> <li>Try It in 20 Seconds</li> <li>Key Features</li> <li>Installation</li> <li>Quick Start</li> <li>Artifacts &amp; Reproducibility</li> <li>API Surface</li> <li>Built-in Commands</li> <li>Tests &amp; Quality</li> <li>Project Tree</li> <li>Docs &amp; Resources</li> <li>Contributing</li> <li>License</li> </ul>"},{"location":"#why-agentic-flows","title":"Why Agentic Flows?","text":"<p>Most agent tooling optimizes for velocity. Agentic Flows prioritizes repeatability, traceability, and audit-ready execution:</p> <ul> <li>Determinism first for reliable experiments and CI validation.</li> <li>Invariant enforcement with fail-fast execution semantics.</li> <li>Replayable traces for deterministic verification.</li> <li>Clear boundaries between execution, retrieval, and verification.</li> </ul> <p></p>"},{"location":"#try-it-in-20-seconds","title":"Try It in 20 Seconds","text":"<pre><code>pipx install agentic-flows  # Or: pip install agentic-flows\nagentic-flows --help\nagentic-flows plan path/to/manifest.json\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Deterministic execution \u2014 reproducible runs with explicit budgets.</li> <li>Contract-first design \u2014 schema and invariants enforced at boundaries.</li> <li>Replayable traces \u2014 audit-grade execution records.</li> <li>Dual surface \u2014 CLI and API share the same contracts.</li> <li>Structured telemetry \u2014 correlation IDs and traceable events.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.11+.</p> <pre><code># Isolated install (recommended)\npipx install agentic-flows\n\n# Standard\npip install agentic-flows\n</code></pre> <p>Upgrade: <code>pipx upgrade agentic-flows</code> or <code>pip install --upgrade agentic-flows</code>.</p> <p></p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Discover commands/flags\nagentic-flows --help\n\n# Plan a flow from a manifest\nagentic-flows plan path/to/manifest.json\n\n# Run a deterministic execution\nagentic-flows run path/to/manifest.json --db-path /tmp/execution.duckdb\n</code></pre>"},{"location":"#artifacts-reproducibility","title":"Artifacts &amp; Reproducibility","text":"<p>Artifacts are immutable and hash-addressed. Replaying a run verifies hashes before returning outputs.</p> <pre><code>agentic-flows diff run &lt;run_a&gt; &lt;run_b&gt; --tenant-id &lt;tenant&gt; --db-path /tmp/execution.duckdb\n</code></pre> <p>Docs: Execution Lifecycle \u00b7 Invariants</p> <p></p>"},{"location":"#api-surface","title":"API Surface","text":"<p>The HTTP API exposes the same contracts as the CLI.</p> <p>Docs: API Overview \u00b7 Schema</p> <p></p>"},{"location":"#built-in-commands","title":"Built-in Commands","text":"Command Description Example <code>plan</code> Resolve a manifest into a plan <code>agentic-flows plan manifest.json</code> <code>run</code> Execute a flow <code>agentic-flows run manifest.json --db-path /tmp/flow.duckdb</code> <code>dry-run</code> Trace execution without calling tools <code>agentic-flows dry-run manifest.json --db-path /tmp/flow.duckdb</code> <code>inspect run</code> Inspect a stored run <code>agentic-flows inspect run &lt;run_id&gt; --tenant-id &lt;tenant&gt; --db-path /tmp/flow.duckdb</code> <code>diff run</code> Compare two runs <code>agentic-flows diff run &lt;a&gt; &lt;b&gt; --tenant-id &lt;tenant&gt; --db-path /tmp/flow.duckdb</code> <p>Full surface: CLI Surface</p> <p></p>"},{"location":"#tests-quality","title":"Tests &amp; Quality","text":"<ul> <li>Coverage floors: enforced per module in CI.</li> <li>Benchmarks: regression gate on critical path.</li> <li>Docs: linted and built in CI.</li> </ul> <p>Quick commands:</p> <pre><code>make test\nmake lint\nmake quality\n</code></pre> <p>Artifacts: Generated in CI; see GitHub Actions for logs and reports.</p> <p></p>"},{"location":"#project-tree","title":"Project Tree","text":"<pre><code>api/            # OpenAPI schemas\nconfig/         # Lint/type/security configs\ndocs/           # MkDocs site\nmakefiles/      # Task modules (docs, test, lint, etc.)\nscripts/        # Helper scripts\nsrc/agentic_flows/  # Runtime + CLI implementation\ntests/          # unit / regression / e2e\n</code></pre>"},{"location":"#docs-resources","title":"Docs &amp; Resources","text":"<ul> <li>Overview: Why agentic-flows exists \u00b7 Mental model \u00b7 Minimal run \u00b7 Relationship to agentic-proteins \u00b7 Audience</li> <li>Concepts: Concepts index \u00b7 Determinism \u00b7 Failures</li> <li>Execution: Failure paths</li> <li>Site: https://bijux.github.io/agentic-flows/</li> <li>Changelog: https://github.com/bijux/agentic-flows/blob/main/CHANGELOG.md</li> <li>Repository: https://github.com/bijux/agentic-flows</li> <li>Issues: https://github.com/bijux/agentic-flows/issues</li> <li>Security (private reports): https://github.com/bijux/agentic-flows/security/advisories/new</li> <li>Artifacts: https://bijux.github.io/agentic-flows/artifacts/</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Welcome. See CONTRIBUTING.md for setup and test guidance.</p> <p></p>"},{"location":"#license","title":"License","text":"<p>Apache-2.0 \u2014 see LICENSE. \u00a9 2025 Bijan Mousavi.</p>"},{"location":"api/failures/","title":"Failure taxonomy","text":"<p>Reference mapping for failure envelopes returned by the API.</p> FailureClass ReasonCode Meaning (1 sentence) Expected user action ResolutionFailure INVALID_MANIFEST The flow manifest violates the schema or required invariants. Fix the manifest and re-run. ResolutionFailure PLAN_MISMATCH The resolved plan hash does not match the expected value. Regenerate the plan from the declared manifest. ExecutionFailure EXECUTION_ABORTED The run was cancelled or halted before completion. Inspect cancellation cause and retry if appropriate. ExecutionFailure DATASET_MISMATCH The dataset identity or fingerprint does not match the run contract. Reconcile dataset versioning and retry with the correct dataset. RetrievalFailure EVIDENCE_MISSING Required evidence could not be retrieved deterministically. Restore evidence sources or adjust retrieval contracts. ReasoningFailure CLAIM_CONFLICT Reasoning claims contradict required evidence constraints. Revise the reasoning policy or inputs. ReplayUnacceptable explicit Replay exceeded the declared acceptability threshold. Re-run with a compatible dataset/policy or lower the acceptability threshold. VerificationFailure VERIFICATION_CONFLICT Verification engines disagree beyond the allowed threshold. Review arbitration policy and tighten evidence requirements. SemanticViolationError UNAUTHORIZED_ENTROPY An entropy source was used without explicit authorization. Update the policy to authorize the source or remove it. VerificationFailure CONTRACT_VIOLATION The run violates a declared contract or invariant. Fix the contract breach and re-run."},{"location":"api/failures/#failure-severity-legend","title":"Failure severity legend","text":"<p>Severity guidance by failure class.</p> <p>FailureClass \u2192 severity ResolutionFailure \u2192 ERROR ExecutionFailure \u2192 FATAL RetrievalFailure \u2192 WARN ReasoningFailure \u2192 ERROR ReplayUnacceptable \u2192 ERROR VerificationFailure \u2192 ERROR SemanticViolationError \u2192 FATAL</p>"},{"location":"api/http_failures/","title":"HTTP failure mapping","text":"<p>HTTP status mapping for failure classes.</p> FailureClass HTTP status Retryable (yes/no) ResolutionFailure 400 no ExecutionFailure 500 no RetrievalFailure 502 yes ReasoningFailure 422 no VerificationFailure 409 no SemanticViolationError 406 no"},{"location":"api/overview/","title":"overview","text":"<p>Scope: HTTP API summary. Audience: API users. Guarantees: Schema compatibility is the only API guarantee; runtime behavior, policy interpretation, and enforcement may evolve. Non-Goals: Authentication. Why: This doc exists to record its single responsibility for review. HTTP API is experimental and currently unimplemented.  </p>"},{"location":"api/overview/#overview_1","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Cli before edits. Read Docs Style for context.  </p>"},{"location":"api/overview/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/api/test_run.py. Contracts link to Cli and Docs Style.  </p>"},{"location":"api/overview/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/api/test_run.py. Invariants align with Cli.  </p>"},{"location":"api/overview/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/api/test_run.py. Failures align with Docs Style.  </p>"},{"location":"api/overview/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Cli. Extensions align with tests/api/test_run.py.  </p>"},{"location":"api/overview/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: tests/api/test_run.py.  </p>"},{"location":"api/public-surface/","title":"Public Surface","text":"<p>Public API surface for v1.</p> <p>public CLI commands: run replay inspect</p> <p>public HTTP endpoints: POST /api/v1/flows/run POST /api/v1/flows/replay</p> <p>public schemas: FlowRunRequest FlowRunResponse ReplayRequest FailureEnvelope</p> <p>Anything not listed here is internal.</p>"},{"location":"api/python_surface/","title":"Python Surface","text":"<p>Public Python imports supported by this release.</p> <p>Functions - agentic_flows.runtime.orchestration.execute_flow.execute_flow - agentic_flows.runtime.orchestration.replay_store.replay_with_store</p> <p>Classes - agentic_flows.runtime.orchestration.execute_flow.ExecutionConfig - agentic_flows.runtime.orchestration.execute_flow.FlowRunResult - agentic_flows.spec.model.FlowManifest - agentic_flows.spec.model.ExecutionPlan - agentic_flows.spec.model.ExecutionTrace - agentic_flows.spec.model.ReplayEnvelope - agentic_flows.spec.model.datasets.dataset_descriptor.DatasetDescriptor - agentic_flows.spec.model.verification.verification.VerificationPolicy - agentic_flows.runtime.observability.storage.execution_store.DuckDBExecutionWriteStore - agentic_flows.runtime.observability.storage.execution_store.DuckDBExecutionReadStore</p> <p>Modules - agentic_flows.spec.ontology.public - agentic_flows.runtime.orchestration.execute_flow - agentic_flows.runtime.orchestration.replay_store - agentic_flows.runtime.observability.storage.execution_store</p> <p>Everything else is internal by default.</p>"},{"location":"api/schema-mapping/","title":"schema-mapping","text":"<p>Scope: API schema to runtime mapping. Audience: API and runtime maintainers. Guarantees: One mapping per API field. Non-Goals: Behavioral semantics beyond invariants. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"api/schema-mapping/#mapping","title":"Mapping","text":"API field Internal class Field Invariant <code>FlowRunRequest.flow_manifest</code> <code>FlowManifest</code> manifest source Must resolve to a single manifest. <code>FlowRunRequest.inputs_fingerprint</code> <code>ResolvedStep</code> <code>inputs_fingerprint</code> First step fingerprint anchors deterministic seed. <code>FlowRunRequest.run_mode</code> <code>ExecutionConfig</code> <code>mode</code> Must map to <code>RunMode</code> live/dry/observe. <code>FlowRunRequest.dataset_id</code> <code>DatasetDescriptor</code> <code>dataset_id</code> Dataset identity must be immutable. <code>FlowRunRequest.policy_fingerprint</code> <code>VerificationPolicy</code> fingerprint Policy fingerprint must match execution policy. <code>FlowRunResponse.run_id</code> <code>FlowRunResult</code> <code>run_id</code> Run ID exists for persisted executions. <code>FlowRunResponse.flow_id</code> <code>ExecutionPlan</code> <code>manifest.flow_id</code> Flow identity is stable across replay. <code>FlowRunResponse.status</code> <code>ExecutionTrace</code> execution status Status reflects terminal run outcome. <code>FlowRunResponse.determinism_class</code> <code>DeterminismClass</code> class Determinism class must be declared, not inferred. <code>FlowRunResponse.replay_acceptability</code> <code>ReplayAcceptability</code> acceptability Replay acceptability matches manifest. <code>FlowRunResponse.artifact_count</code> <code>ExecutionTrace</code> artifact count Count reflects persisted artifacts. <code>ReplayRequest.run_id</code> <code>ExecutionTrace</code> <code>run_id</code> Replay references a stored run. <code>ReplayRequest.expected_plan_hash</code> <code>ExecutionSteps</code> <code>plan_hash</code> Plan hash must match stored plan. <code>ReplayRequest.acceptability_threshold</code> <code>ReplayAcceptability</code> threshold Replay must meet or exceed threshold. <code>ReplayRequest.observer_mode</code> <code>ExecutionConfig</code> <code>mode</code> Observer mode cannot mutate state. <code>FailureEnvelope.failure_class</code> <code>FailureClass</code> class Failure class is structural or semantic. <code>FailureEnvelope.reason_code</code> <code>ReasonCode</code> code Reason codes are enumerated. <code>FailureEnvelope.violated_contract</code> <code>ContractID</code> contract Violated contract must be explicit. <code>FailureEnvelope.evidence_ids</code> <code>EvidenceID</code> evidence IDs Evidence identifiers must be stable. <code>FailureEnvelope.determinism_impact</code> <code>DeterminismClass</code> impact Impact reflects declared determinism class. <code>X-Agentic-Gate</code> <code>GateID</code> gate Gate identifier must be declared. <code>X-Determinism-Level</code> <code>DeterminismLevel</code> level Determinism level controls enforcement. <code>X-Policy-Fingerprint</code> <code>VerificationPolicy</code> fingerprint Fingerprint must match policy hash."},{"location":"api/schema/","title":"schema","text":"<p>Scope: OpenAPI schema contract. Audience: API users and contributors. Guarantees: Schema file is authoritative. Non-Goals: Client SDK generation. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"api/schema/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Overview before edits. Read Docs Style for context.  </p>"},{"location":"api/schema/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with api/v1/schema.yaml. Contracts link to Overview and Docs Style.  </p>"},{"location":"api/schema/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with api/v1/schema.yaml. Invariants align with Overview.  </p>"},{"location":"api/schema/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with api/v1/schema.yaml. Failures align with Docs Style.  </p>"},{"location":"api/schema/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Overview. Extensions align with api/v1/schema.yaml.  </p>"},{"location":"api/schema/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: api/v1/schema.yaml.  </p>"},{"location":"api/examples/replay_rejected/","title":"Replay Rejected Example","text":"<p>Example of a replay rejection response.</p> <p>request payload: {\"run_id\":\"run-123\",\"expected_plan_hash\":\"plan-mismatch\",\"acceptability_threshold\":\"exact_match\",\"observer_mode\":false}</p> <p>response payload: {\"failure_class\":\"structural\",\"reason_code\":\"contradiction_detected\",\"violated_contract\":\"plan_hash\",\"evidence_ids\":[],\"determinism_impact\":\"structural\"}</p> <p>HTTP status: 406</p> <p>short explanation: replay rejected because the expected plan hash does not match the stored run.</p>"},{"location":"architecture/abstraction_removal/","title":"abstraction_removal","text":"<p>Scope: Removal of unused abstraction layers. Audience: Contributors and reviewers. Guarantees: Removed layers are documented and tested. Non-Goals: Historical narrative. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/abstraction_removal/#overview","title":"Overview","text":"<p>This doc records the abstraction removal. Architecture components are defined in Architecture. Read Docs Style for structure.  </p>"},{"location":"architecture/abstraction_removal/#contracts","title":"Contracts","text":"<p>The contracts interface layer was removed. The registry base class was removed. The registry re-export indirection was removed.  </p>"},{"location":"architecture/abstraction_removal/#invariants","title":"Invariants","text":"<p>Direct imports replace removed layers. Registry behavior remains explicit. Public interfaces remain tested.  </p>"},{"location":"architecture/abstraction_removal/#failure-modes","title":"Failure Modes","text":"<p>Missing imports fail tests. Unexpected coupling fails review. Undefined layers are rejected.  </p>"},{"location":"architecture/abstraction_removal/#extension-points","title":"Extension Points","text":"<p>Removals update Design Debt. Public interface changes update Core. Documentation updates follow Triage.  </p>"},{"location":"architecture/abstraction_removal/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when removals are generated. The replacement is Core. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/registry/agents.py.  </p>"},{"location":"architecture/architecture-note/","title":"architecture-note","text":"<p>Scope: Determinism, replay, and contracts rationale. Audience: Senior engineers. Guarantees: Clear justification without marketing. Non-Goals: Implementation tutorial. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/architecture-note/#why-determinism","title":"Why Determinism","text":"<p>Determinism is the only way to make results comparable over time. Without it, regressions hide inside noise, and every run becomes an anecdote. A deterministic system turns execution into evidence. It makes failures reproducible and makes success meaningful.  </p> <p>Determinism here does not mean no entropy. It means entropy is explicit, bounded, and accounted for. When you declare the acceptable sources of nondeterminism, you make divergence a contract violation instead of a mystery.  </p>"},{"location":"architecture/architecture-note/#why-replay","title":"Why Replay","text":"<p>Replay is the audit path. A system that cannot replay cannot prove that a result was produced under the declared constraints. Replay provides the second execution that validates the first and exposes drift in data, environment, or behavior.  </p> <p>Replay also forces you to define minimal inputs. If you cannot replay with recorded inputs, then your system depends on hidden state. Hidden state is the enemy of trust and the cause of hard-to-debug regressions.  </p>"},{"location":"architecture/architecture-note/#why-contracts-over-heuristics","title":"Why Contracts Over Heuristics","text":"<p>Heuristics tolerate ambiguity. Contracts reject it. A contract-first system specifies what must be true before and after each phase, so violations are caught immediately. This is more valuable than adding fallback behavior because it protects the integrity of the run.  </p> <p>Contracts are also the only scalable governance mechanism. As the system grows, a contract is stable and testable. Heuristics drift, expand, and become folklore.  </p>"},{"location":"architecture/architecture-note/#summary","title":"Summary","text":"<p>Determinism makes outcomes comparable, replay makes outcomes verifiable, and contracts make outcomes enforceable. The combination turns agent execution into an auditable process rather than a best-effort workflow.  </p>"},{"location":"architecture/architecture/","title":"architecture","text":"<p>Scope: Architecture single source of truth. Audience: Contributors and reviewers. Guarantees: Diagram and narrative are canonical. Non-Goals: Alternative diagrams or component redefinitions. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/architecture/#overview","title":"Overview","text":"<p>Architecture components are defined here and referenced elsewhere. Read Core Concepts for vocabulary. Read Docs Style for structure.  </p>"},{"location":"architecture/architecture/#contracts","title":"Contracts","text":"<p>The diagram below is the single source of truth. The narrative below defines component roles. Other docs reference this page for components. Diagram: CLI -&gt; runtime control &lt;- API -&gt; providers -&gt; artifacts -&gt; evaluation artifact. CLI and API submit requests to runtime control, which coordinates providers and writes artifacts.  </p>"},{"location":"architecture/architecture/#invariants","title":"Invariants","text":"<p>Runtime control records each execution unit. Providers are isolated from runtime control state. Artifacts are immutable after write.  </p>"},{"location":"architecture/architecture/#failure-modes","title":"Failure Modes","text":"<p>Component drift creates inconsistent behavior. Missing references cause documentation mismatch. Broken links invalidate the diagram contract.  </p>"},{"location":"architecture/architecture/#extension-points","title":"Extension Points","text":"<p>Architecture changes update Invariants. Architecture changes update Execution Model. Architecture changes update Execution Lifecycle.  </p>"},{"location":"architecture/architecture/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when architecture is generated. The replacement is Invariants. Obsolete docs are removed.  </p> <p>Code refs: tests/integration/test_runtime_flow.py.  </p>"},{"location":"architecture/conservation/","title":"conservation","text":"<p>Scope: Global conservation checks. Audience: Contributors and reviewers. Guarantees: Conservation violations stop execution. Non-Goals: Biological realism beyond constraints. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/conservation/#overview","title":"Overview","text":"<p>This doc defines pathway-level conservation checks. Architecture components are defined in Architecture. Read Docs Style for structure.  </p>"},{"location":"architecture/conservation/#contracts","title":"Contracts","text":"<p>Total energy is bounded by a minimum. Activation mass is capped per pathway. Resource dependencies are validated against a pool.  </p>"},{"location":"architecture/conservation/#invariants","title":"Invariants","text":"<p>Violations are detected and logged. Execution stops on violation. Checks apply to every tick.  </p>"},{"location":"architecture/conservation/#failure-modes","title":"Failure Modes","text":"<p>Energy violations raise errors. Activation mass violations raise errors. Resource violations raise errors.  </p>"},{"location":"architecture/conservation/#extension-points","title":"Extension Points","text":"<p>Conservation changes update Metrics. Contract changes update Pathway Limits. Documentation updates follow Triage.  </p>"},{"location":"architecture/conservation/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when checks are generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/pathway.py.  </p>"},{"location":"architecture/design_debt/","title":"design_debt","text":"<p>Scope: Design debt ledger. Audience: Contributors. Guarantees: Ledger contains &lt;=10 items with exits. Non-Goals: Issue tracking. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/design_debt/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Triage before edits. Read Docs Style for context.  </p>"},{"location":"architecture/design_debt/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with scripts/check_design_debt.py. Contracts link to Triage and Docs Style.  </p>"},{"location":"architecture/design_debt/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with scripts/check_design_debt.py. Invariants align with Triage.  </p>"},{"location":"architecture/design_debt/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with scripts/check_design_debt.py. Failures align with Docs Style.  </p>"},{"location":"architecture/design_debt/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Triage. Extensions align with scripts/check_design_debt.py.  </p>"},{"location":"architecture/design_debt/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: scripts/check_design_debt.py.  </p>"},{"location":"architecture/execution_cost/","title":"execution_cost","text":"<p>Scope: Canonical execution cost per tick. Audience: Contributors and reviewers. Guarantees: Cost fields are defined and recorded. Non-Goals: Benchmark optimization. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/execution_cost/#overview","title":"Overview","text":"<p>This doc defines canonical execution cost. Architecture components are defined in Architecture. Read Docs Style for structure.  </p>"},{"location":"architecture/execution_cost/#contracts","title":"Contracts","text":"<p>CPU time is recorded per tick. Memory usage is recorded per tick. Agent count and signal volume are recorded per tick.  </p>"},{"location":"architecture/execution_cost/#invariants","title":"Invariants","text":"<p>Cost records are appended per step. Cost fields are numeric and non-negative. Cost recording does not mutate state.  </p>"},{"location":"architecture/execution_cost/#failure-modes","title":"Failure Modes","text":"<p>Missing cost records fail tests. Negative values fail validation. Inconsistent ticks fail review.  </p>"},{"location":"architecture/execution_cost/#extension-points","title":"Extension Points","text":"<p>Cost changes update Metrics. Stress tests update Pathway Limits. Documentation updates follow Triage.  </p>"},{"location":"architecture/execution_cost/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when costs are generated. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/pathway.py.  </p>"},{"location":"architecture/execution_lifecycle/","title":"execution_lifecycle","text":"<p>Scope: Execution lifecycle state machine. Audience: Contributors and reviewers. Guarantees: States and transitions are explicit. Non-Goals: Alternate lifecycles. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/execution_lifecycle/#overview","title":"Overview","text":"<p>This doc defines the execution lifecycle state machine. Read Architecture for component context. Read Core Concepts for vocabulary.  </p>"},{"location":"architecture/execution_lifecycle/#contracts","title":"Contracts","text":"<p>States and transitions are listed below. The lifecycle uses a single linear progression. Deviations are failures. - init -&gt; plan - plan -&gt; act - act -&gt; observe - observe -&gt; evaluate - evaluate -&gt; terminate - terminate -&gt; terminate  </p>"},{"location":"architecture/execution_lifecycle/#invariants","title":"Invariants","text":"<p>State order is init, plan, act, observe, evaluate, terminate. Each execution unit records its state. Transitions align with Execution Model.  </p>"},{"location":"architecture/execution_lifecycle/#failure-modes","title":"Failure Modes","text":"<p>Out-of-order transitions break traceability. Missing states break evaluation artifact records. Lifecycle drift breaks Architecture.  </p>"},{"location":"architecture/execution_lifecycle/#extension-points","title":"Extension Points","text":"<p>Lifecycle changes update Execution Model. Lifecycle changes update Invariants. Lifecycle changes update Core Concepts.  </p>"},{"location":"architecture/execution_lifecycle/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when execution is generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/integration/test_runtime_flow.py.  </p>"},{"location":"architecture/execution_model/","title":"execution_model","text":"<p>Scope: Deterministic versus agentic boundary. Audience: Contributors and reviewers. Guarantees: Boundaries are explicit and testable. Non-Goals: Provider-specific behavior. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/execution_model/#overview","title":"Overview","text":"<p>This doc defines deterministic and agentic boundaries. Read Architecture for component context. Read Core Concepts for vocabulary.  </p>"},{"location":"architecture/execution_model/#contracts","title":"Contracts","text":"<p>Deterministic behavior covers state transitions and artifact hashing. The execution contract is recorded in src/agentic_proteins/core/contracts.py. Agentic behavior is limited to provider outputs and selection.  </p>"},{"location":"architecture/execution_model/#invariants","title":"Invariants","text":"<p>Deterministic paths use fixed inputs and seeds. Agentic paths record every decision and output. Boundaries align with Invariants.  </p>"},{"location":"architecture/execution_model/#failure-modes","title":"Failure Modes","text":"<p>Untracked stochastic output breaks reproducibility. Missing logs break traceability. Boundary drift breaks Architecture.  </p>"},{"location":"architecture/execution_model/#extension-points","title":"Extension Points","text":"<p>Boundary changes update Execution Lifecycle. Boundary changes update Invariants. Boundary changes update Core Concepts.  </p>"},{"location":"architecture/execution_model/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when execution is generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"architecture/experimental/","title":"experimental","text":"<p>Scope: Experimental provider rules. Audience: Contributors and opt-in users. Guarantees: Experimental providers are namespaced. Non-Goals: Provider-specific behavior. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/experimental/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Docs Style before edits. Read Naming for context.  </p>"},{"location":"architecture/experimental/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/unit/test_experimental_provider_namespace.py. Contracts link to Docs Style and Naming.  </p>"},{"location":"architecture/experimental/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/unit/test_experimental_provider_namespace.py. Invariants align with Docs Style.  </p>"},{"location":"architecture/experimental/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/unit/test_experimental_provider_namespace.py. Failures align with Naming.  </p>"},{"location":"architecture/experimental/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Docs Style. Extensions align with tests/unit/test_experimental_provider_namespace.py.  </p>"},{"location":"architecture/experimental/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Naming. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_experimental_provider_namespace.py.  </p>"},{"location":"architecture/invariants/","title":"invariants","text":"<p>Scope: Architectural invariants. Audience: Contributors. Guarantees: Invariants map to tests. Non-Goals: Rationale narrative. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/invariants/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Docs Style before edits. Read Triage for context.  </p>"},{"location":"architecture/invariants/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/regression/test_architecture_invariants.py. Contracts link to Docs Style and Triage.  </p>"},{"location":"architecture/invariants/#invariants_1","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/regression/test_architecture_invariants.py. Invariants align with Docs Style.  </p>"},{"location":"architecture/invariants/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/regression/test_architecture_invariants.py. Failures align with Triage.  </p>"},{"location":"architecture/invariants/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Docs Style. Extensions align with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"architecture/invariants/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Triage. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"architecture/llm_authority/","title":"llm_authority","text":"<p>Scope: LLM authority boundary. Audience: Contributors and reviewers. Guarantees: LLM actions are bounded and enforced. Non-Goals: Model benchmarking. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/llm_authority/#overview","title":"Overview","text":"<p>This doc defines the LLM authority boundary. Architecture components are defined in Architecture. Read Core Concepts for vocabulary. Read Docs Style for structure.  </p>"},{"location":"architecture/llm_authority/#contracts","title":"Contracts","text":"<p>Allowed actions are tuning only. Forbidden actions include any state mutation. Read-only and write-through permissions are explicit.  </p>"},{"location":"architecture/llm_authority/#invariants","title":"Invariants","text":"<p>Proposals never mutate state directly. Validation rejects invalid proposals. Approvals gate all proposal application.  </p>"},{"location":"architecture/llm_authority/#failure-modes","title":"Failure Modes","text":"<p>Forbidden actions raise errors. Invalid proposals are rejected and logged. Missing approvals block proposal application.  </p>"},{"location":"architecture/llm_authority/#extension-points","title":"Extension Points","text":"<p>Authority changes update Docs Style. Authority changes update Core Concepts. Authority changes update Architecture.  </p>"},{"location":"architecture/llm_authority/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when authority is generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/regulator.py.  </p>"},{"location":"architecture/metrics/","title":"metrics","text":"<p>Scope: Minimal metrics set. Audience: Contributors and reviewers. Guarantees: Metrics are defined and computed. Non-Goals: Comprehensive analytics. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/metrics/#overview","title":"Overview","text":"<p>This doc defines the minimal metrics set. Architecture components are defined in Architecture. Read Execution Cost for cost context.  </p>"},{"location":"architecture/metrics/#contracts","title":"Contracts","text":"<p>Pathway throughput is reported. Failure rate is reported. Recovery success is reported. Signal entropy is reported. LLM intervention delta is reported.  </p>"},{"location":"architecture/metrics/#invariants","title":"Invariants","text":"<p>Metrics are computed from event logs. Metrics never mutate pathway state. Metrics are deterministic for fixed logs.  </p>"},{"location":"architecture/metrics/#failure-modes","title":"Failure Modes","text":"<p>Missing metrics fail tests. Undefined metrics are rejected. Non-deterministic metrics are rejected.  </p>"},{"location":"architecture/metrics/#extension-points","title":"Extension Points","text":"<p>Metric changes update Execution Cost. Stress tests update Pathway Limits. Documentation updates follow Triage.  </p>"},{"location":"architecture/metrics/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when metrics are generated. The replacement is Execution Cost. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/pathway.py.  </p>"},{"location":"architecture/negative_results/","title":"negative_results","text":"<p>Scope: Negative results criteria. Audience: Contributors and reviewers. Guarantees: Failure scenarios are explicit and tested. Non-Goals: Success narratives. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/negative_results/#overview","title":"Overview","text":"<p>This doc defines negative results scenarios. Architecture components are defined in Architecture. Read Metrics for measurement context.  </p>"},{"location":"architecture/negative_results/#contracts","title":"Contracts","text":"<p>A cyclic pathway must fail validation. A proposal that increases energy cost must worsen stability. Degraded proteins must not recover.  </p>"},{"location":"architecture/negative_results/#invariants","title":"Invariants","text":"<p>Negative results are enforced by tests. Failures are structured and observable. No hidden recovery is allowed.  </p>"},{"location":"architecture/negative_results/#failure-modes","title":"Failure Modes","text":"<p>Silent success invalidates results. Missing failures invalidate tests. Undefined scenarios are rejected.  </p>"},{"location":"architecture/negative_results/#extension-points","title":"Extension Points","text":"<p>Scenario changes update Metrics. Contract changes update Pathway Limits. Documentation updates follow Triage.  </p>"},{"location":"architecture/negative_results/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when results are generated. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_negative_results.py.  </p>"},{"location":"architecture/observability/","title":"Observability","text":""},{"location":"architecture/observability/#capture","title":"Capture","text":"<p>Capture collects runtime signals into structured trace data for a single flow run. It focuses on recording events, timestamps, and environment fingerprints in a consistent sequence. Capture does not evaluate or interpret the meaning of events, and it does not enforce policy outcomes.</p>"},{"location":"architecture/observability/#storage","title":"Storage","text":"<p>Storage persists trace data, artifacts, and related metadata for later replay and analysis. It guarantees durable, queryable records with stable schema contracts. Storage does not perform analysis or classification of determinism, and it does not mutate datasets.</p>"},{"location":"architecture/observability/#analysis","title":"Analysis","text":"<p>Analysis compares traces, detects drift, and computes replay deltas for verification. It summarizes changes into structured outputs that can be consumed by higher-level decision logic. Analysis does not write to storage and does not change the underlying trace data.</p>"},{"location":"architecture/observability/#classification","title":"Classification","text":"<p>Classification assigns determinism classes, entropy sources, and fingerprints to recorded events. It provides consistent labels for interpretation and reporting across the system. Classification does not execute flows and does not decide acceptability.</p>"},{"location":"architecture/pathway_limits/","title":"pathway_limits","text":"<p>Scope: Hard limits for agent interactions. Audience: Contributors and reviewers. Guarantees: Limits are enforced at runtime. Non-Goals: Adaptive scaling. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"architecture/pathway_limits/#overview","title":"Overview","text":"<p>This doc defines pathway interaction limits. Architecture components are defined in Architecture. Read Docs Style for structure.  </p>"},{"location":"architecture/pathway_limits/#contracts","title":"Contracts","text":"<p>Incoming signals per tick are capped. Outgoing signals per tick are capped. Dependency depth is capped.  </p>"},{"location":"architecture/pathway_limits/#invariants","title":"Invariants","text":"<p>Limits apply to every pathway. Limit violations stop execution. Limits are recorded in tests.  </p>"},{"location":"architecture/pathway_limits/#failure-modes","title":"Failure Modes","text":"<p>Limit violations raise errors. Silent overflow is rejected. Cycles are blocked by contract rules.  </p>"},{"location":"architecture/pathway_limits/#extension-points","title":"Extension Points","text":"<p>Limit changes update Execution Cost. Contract changes update Architecture. Documentation updates follow Triage.  </p>"},{"location":"architecture/pathway_limits/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when limits are generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/pathway.py.  </p>"},{"location":"cli/cli/","title":"cli","text":"<p>Scope: CLI command contract. Audience: Users and contributors. Guarantees: Commands listed here are stable. Non-Goals: Usage examples. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"cli/cli/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Core Concepts for vocabulary. Read Docs Style before edits. Read Cli Surface for context.  </p>"},{"location":"cli/cli/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/integration/test_cli.py. Contracts link to Docs Style and Cli Surface.  </p>"},{"location":"cli/cli/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/integration/test_cli.py. Invariants align with Docs Style.  </p>"},{"location":"cli/cli/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/integration/test_cli.py. Failures align with Cli Surface.  </p>"},{"location":"cli/cli/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Docs Style. Extensions align with tests/integration/test_cli.py.  </p>"},{"location":"cli/cli/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Cli Surface. Obsolete docs are removed.  </p> <p>Code refs: tests/integration/test_cli.py.  </p>"},{"location":"concepts/","title":"concepts","text":"<p>Scope: Concept summaries. Audience: Readers learning the vocabulary. Guarantees: Short definitions and links. Non-Goals: Deep technical detail. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"concepts/#flow","title":"Flow","text":"<p>A flow is the ordered execution of steps under one determinism and policy contract. It is the unit of replay.  </p>"},{"location":"concepts/#step","title":"Step","text":"<p>A step is a bounded unit of work in a flow. Steps emit events and produce artifacts.  </p>"},{"location":"concepts/#artifact","title":"Artifact","text":"<p>An artifact is an immutable output produced by a step. Artifacts are hash-addressed and replayed.  </p>"},{"location":"concepts/#evidence","title":"Evidence","text":"<p>Evidence is the traceable input that supports or contradicts reasoning. It is stored and replayed alongside artifacts.  </p>"},{"location":"concepts/#determinism","title":"Determinism","text":"<p>Determinism is the guarantee that the same inputs yield the same outputs within declared bounds. It is enforced, not assumed.  </p>"},{"location":"concepts/#replay","title":"Replay","text":"<p>Replay re-executes a flow to confirm outputs and detect divergence. It is the audit path, not a debug convenience.  </p>"},{"location":"concepts/#pages","title":"Pages","text":"<ul> <li>Core Concepts </li> <li>Determinism </li> <li>Failures </li> <li>Failure Taxonomy </li> </ul>"},{"location":"concepts/core_concepts/","title":"core_concepts","text":"<p>Scope: Closed vocabulary for core concepts. Audience: Contributors and reviewers. Guarantees: Definitions are canonical and enforced. Non-Goals: Expanded domain theory. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"concepts/core_concepts/#overview","title":"Overview","text":"<p>Core concepts are defined as a closed vocabulary. Read Docs Style before edits. Architecture components are defined in Architecture.  </p>"},{"location":"concepts/core_concepts/#contracts","title":"Contracts","text":"<p>Definitions below are the only canonical wording. All docs reference this page for vocabulary. Terms are linked when used. - agent: An agent is a stateful decision unit that selects a tool and emits actions. - tool: A tool is a callable capability used by an agent within an execution unit. - policy: A policy is a constraint set that governs agent decisions and tool usage. - execution unit: An execution unit is a bounded step that applies a tool and records outputs. - evaluation artifact: An evaluation artifact is a stored result from scoring or validation. - protein: A protein is a constrained agent with explicit state and constraints. - signal: A signal is a typed input that triggers a state transition. - pathway: A pathway is a multi-agent system of protein agents. - regulation: Regulation is bounded proposal tuning that never mutates state. - cell: A cell is an execution environment for pathways.  </p>"},{"location":"concepts/core_concepts/#invariants","title":"Invariants","text":"<p>Canonical wording is enforced in Naming. Aliases are not used in docs. Vocabulary aligns with Getting Started. failure semantics align with Invariants.  </p>"},{"location":"concepts/core_concepts/#failure-modes","title":"Failure Modes","text":"<p>Alias usage fails docs lint. Unlinked terms fail docs lint. Redefinition outside this page fails review. recovery semantics align with Invariants.  </p>"},{"location":"concepts/core_concepts/#extension-points","title":"Extension Points","text":"<p>Change requests follow Triage. Updates propagate to Getting Started. Updates propagate to Architecture.  </p>"},{"location":"concepts/core_concepts/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when vocabulary is generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_docs_contract.py.  </p>"},{"location":"concepts/determinism/","title":"determinism","text":"<p>Scope: Determinism narrative. Audience: Readers evaluating replay guarantees. Guarantees: Explains why and how determinism is enforced. Non-Goals: Formal specifications or enums. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"concepts/determinism/#motivation","title":"Motivation","text":"<p>Determinism makes results trustworthy. If two runs cannot be compared, you cannot prove progress, regression, or integrity.  </p>"},{"location":"concepts/determinism/#threats","title":"Threats","text":"<p>Hidden randomness, mutable datasets, and silent retries erase causality. They make a run look consistent while changing the meaning of its outputs.  </p>"},{"location":"concepts/determinism/#enforcement","title":"Enforcement","text":"<p>Agentic-flows requires explicit budgets, declared entropy sources, and immutable artifacts. The system records what happened and refuses to accept unverifiable output.  </p>"},{"location":"concepts/determinism/#failure-modes","title":"Failure Modes","text":"<p>When determinism is violated, replay diverges and the run is rejected. The system treats divergence as a signal, not a nuisance.  </p>"},{"location":"concepts/failure-taxonomy/","title":"failure-taxonomy","text":"<p>Scope: Failure class meaning and action. Audience: Operators and reviewers. Guarantees: Each class maps to a clear response. Non-Goals: Implementation detail. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"concepts/failure-taxonomy/#taxonomy","title":"Taxonomy","text":"FailureClass Meaning User action structural The run violated declared structure or ordering. Fix the flow manifest, dataset descriptor, or execution ordering. semantic Reasoning or evidence failed verification. Correct claims, evidence, or policy expectations. environmental The execution environment drifted from the declared fingerprint. Rebuild environment to match the plan. authority An unauthorized action or entropy source was used. Remove or explicitly authorize the source."},{"location":"concepts/failures/","title":"failures","text":"<p>Scope: Failure taxonomy explained. Audience: Operators and reviewers. Guarantees: Human-readable failure classification. Non-Goals: Stack traces or raw logs. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"concepts/failures/#overview","title":"Overview","text":"<p>Failure classes exist to make blame clear and resolution consistent. Instead of debating symptoms, you classify what failed and follow the correct recovery path.  </p>"},{"location":"concepts/failures/#examples","title":"Examples","text":"<p>A dataset mismatch means the run used different source data than expected, even if outputs look similar. A nondeterminism violation means the system observed unapproved entropy, so replay can no longer be trusted. A verification conflict means reasoning and evidence disagree, so the run is invalid even if execution completed. A budget exhaustion means the run exceeded declared limits and must be rejected.  </p>"},{"location":"concepts/failures/#why-it-matters","title":"Why It Matters","text":"<p>Operators should be able to classify a failure without reading code. The class tells you whether to fix the data, the policy, or the execution path.  </p>"},{"location":"concepts/failures/#related","title":"Related","text":"<p>See Failure Taxonomy for the class-to-action mapping.  </p>"},{"location":"execution/failure-paths/","title":"failure-paths","text":"<p>Scope: Execution failure paths. Audience: Operators and reviewers. Guarantees: Clear triggers, detection, and outcomes. Non-Goals: Implementation detail. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"execution/failure-paths/#dataset-mismatch","title":"Dataset Mismatch","text":"<ul> <li>Trigger: The dataset fingerprint differs from the declared dataset.  </li> <li>Detection point: Replay validation before step execution.  </li> <li>Outcome: Run rejected; replay marked invalid.  </li> </ul>"},{"location":"execution/failure-paths/#non-determinism-violation","title":"Non-Determinism Violation","text":"<ul> <li>Trigger: An entropy source appears without authorization.  </li> <li>Detection point: Runtime entropy ledger on first use.  </li> <li>Outcome: Run aborted; trace marked non-replayable.  </li> </ul>"},{"location":"execution/failure-paths/#verification-conflict","title":"Verification Conflict","text":"<ul> <li>Trigger: Evidence contradicts reasoning claims.  </li> <li>Detection point: Verification gate after reasoning bundle.  </li> <li>Outcome: Run rejected; verification failure recorded.  </li> </ul>"},{"location":"execution/failure-paths/#budget-exhaustion","title":"Budget Exhaustion","text":"<ul> <li>Trigger: Entropy or rule cost exceeds declared budget.  </li> <li>Detection point: Budget accounting during execution.  </li> <li>Outcome: Run terminated; failure classified as budget exhaustion.  </li> </ul>"},{"location":"externalization/golden_path/","title":"golden_path","text":"<p>Scope: Canonical golden path example. Audience: External users and contributors. Guarantees: Example uses MPI only. Non-Goals: Full tutorial. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/golden_path/#overview","title":"Overview","text":"<p>This doc points to the canonical example. MPI context lives in Mpi. Architecture context lives in Architecture.  </p>"},{"location":"externalization/golden_path/#contracts","title":"Contracts","text":"<p>The example uses only MPI entry points. The example shows agenticity, failure, and recovery. The example runtime stays under 60 seconds on default hardware. Example code lives in scripts/golden_path_example.py.  </p>"},{"location":"externalization/golden_path/#invariants","title":"Invariants","text":"<p>The golden path remains single and canonical. Evidence aligns with tests/regression/test_negative_results.py. MPI meaning aligns with Core Concepts.  </p>"},{"location":"externalization/golden_path/#failure-modes","title":"Failure Modes","text":"<p>Multiple examples dilute Mpi. Hidden dependencies break Core. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/golden_path/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Surface Area.  </p>"},{"location":"externalization/golden_path/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when examples are generated. The replacement is Mpi. Obsolete docs are removed.  </p> <p>Code refs: scripts/golden_path_example.py.  </p>"},{"location":"externalization/invariant_visualization/","title":"invariant_visualization","text":"<p>Scope: Invariant visualization tooling. Audience: External users and contributors. Guarantees: Per-tick invariants are observable. Non-Goals: GUI tooling. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/invariant_visualization/#overview","title":"Overview","text":"<p>This doc describes invariant visualization. Architecture context lives in Conservation. Metrics context lives in Metrics.  </p>"},{"location":"externalization/invariant_visualization/#contracts","title":"Contracts","text":"<p>Per-tick invariant snapshots are recorded by PathwayExecutor. Violations are captured in the invariant log. Visualization uses scripts/visualize_invariants.py.  </p>"},{"location":"externalization/invariant_visualization/#invariants","title":"Invariants","text":"<p>Invariant visibility aligns with Invariants. Snapshot format aligns with tests/unit/test_execution_cost.py. MPI meaning aligns with Mpi.  </p>"},{"location":"externalization/invariant_visualization/#failure-modes","title":"Failure Modes","text":"<p>Missing snapshots hide violations. Drift in logs breaks Conservation. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/invariant_visualization/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Surface Area.  </p>"},{"location":"externalization/invariant_visualization/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when visualization is generated. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: scripts/visualize_invariants.py.  </p>"},{"location":"externalization/misuse_guards/","title":"misuse_guards","text":"<p>Scope: Runtime misuse guards. Audience: External users and contributors. Guarantees: Guardrails fail loudly. Non-Goals: Error recovery policy. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/misuse_guards/#overview","title":"Overview","text":"<p>This doc lists misuse guards. MPI context lives in Mpi. Architecture context lives in Invariants.  </p>"},{"location":"externalization/misuse_guards/#contracts","title":"Contracts","text":"<p>Direct state mutation is rejected by ProteinAgent. Invariant checks run per tick in PathwayExecutor. Unauthorized LLM actions raise in LLMRegulator.  </p>"},{"location":"externalization/misuse_guards/#invariants","title":"Invariants","text":"<p>Guards align with Core. Guard tests align with tests/unit/test_protein_agent.py. Guard tests align with tests/unit/test_llm_regulator.py.  </p>"},{"location":"externalization/misuse_guards/#failure-modes","title":"Failure Modes","text":"<p>Bypass attempts break Invariants. Silent failures break Core. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/misuse_guards/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Surface Area.  </p>"},{"location":"externalization/misuse_guards/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when guards are generated. The replacement is Invariants. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/protein_agent.py.  </p>"},{"location":"externalization/mpi/","title":"mpi","text":"<p>Scope: Minimal public interface (MPI). Audience: External users and contributors. Guarantees: Entry points and contracts are fixed. Non-Goals: Full API inventory. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/mpi/#overview","title":"Overview","text":"<p>This doc lists the MPI entry points. MPI scope aligns with Core. Usage context lives in Golden Path.  </p>"},{"location":"externalization/mpi/#contracts","title":"Contracts","text":"<p>Entry point: CLI. Input is CLI arguments. Output is exit status and workspace artifacts. Entry point: RunManager. Input is a run directory and config. Output is a run result mapping. Entry point: PathwayExecutor.step. Input is a list of SignalPayload. Output is a list of SignalPayload. Entry point: ProteinAgent.apply_signal. Input is a SignalPayload plus ProteinConstraints and ProteinState. Output is a ProteinState. Entry point: SignalPayload. Input is typed fields (source_id, targets, signal_type via SignalType, magnitude). Output is a validated payload instance. Intentionally inaccessible: runtime control, execution runtime, and registry internals.  </p>"},{"location":"externalization/mpi/#invariants","title":"Invariants","text":"<p>MPI size is capped by Surface Area. MPI meaning aligns with Core Concepts. MPI changes require Invariants.  </p>"},{"location":"externalization/mpi/#failure-modes","title":"Failure Modes","text":"<p>MPI expansion breaks Surface Area. Hidden entry points break Core. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/mpi/#extension-points","title":"Extension Points","text":"<p>Extension rules live in Experimental. Playground usage is described in Sandbox. Review rules align with Triage.  </p>"},{"location":"externalization/mpi/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when MPI is generated. The replacement is Surface Area. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/core/surface_area.py.  </p>"},{"location":"externalization/sandbox/","title":"sandbox","text":"<p>Scope: Sandbox separation. Audience: External users and contributors. Guarantees: Core and sandbox remain distinct. Non-Goals: Sandbox feature catalog. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/sandbox/#overview","title":"Overview","text":"<p>This doc defines the sandbox split. Core context lives in Core. Experimental context lives in Experimental.  </p>"},{"location":"externalization/sandbox/#contracts","title":"Contracts","text":"<p>Core modules live under src/agentic_proteins/core. Sandbox modules live under src/agentic_proteins/sandbox. Sandbox code is marked experimental.  </p>"},{"location":"externalization/sandbox/#invariants","title":"Invariants","text":"<p>Core stability aligns with Invariants. Sandbox usage aligns with Experimental. Evidence aligns with tests/unit/test_module_stability.py.  </p>"},{"location":"externalization/sandbox/#failure-modes","title":"Failure Modes","text":"<p>Mixing core and sandbox breaks Core. Unlabeled sandbox code breaks Experimental. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/sandbox/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Mpi.  </p>"},{"location":"externalization/sandbox/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when sandbox is removed. The replacement is Experimental. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/sandbox/init.py.  </p>"},{"location":"externalization/surface_area/","title":"surface_area","text":"<p>Scope: Surface-area budgeting. Audience: External users and contributors. Guarantees: Public surface stays bounded. Non-Goals: Full API listing. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/surface_area/#overview","title":"Overview","text":"<p>This doc defines surface-area budgets. MPI context lives in Mpi. Architecture context lives in Invariants.  </p>"},{"location":"externalization/surface_area/#contracts","title":"Contracts","text":"<p>Public entry points are capped by src/agentic_proteins/core/surface_area.py. Extension points are capped by the same budget. Configuration knobs are capped by the same budget.  </p>"},{"location":"externalization/surface_area/#invariants","title":"Invariants","text":"<p>Budgets align with Core. Budget checks align with tests/unit/test_surface_area_budget.py. Budget changes update Mpi.  </p>"},{"location":"externalization/surface_area/#failure-modes","title":"Failure Modes","text":"<p>Budget overruns trigger review. Untracked entry points break Core. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/surface_area/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Mpi.  </p>"},{"location":"externalization/surface_area/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when budgets are generated. The replacement is Mpi. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/core/surface_area.py.  </p>"},{"location":"externalization/why_not_x/","title":"why_not_x","text":"<p>Scope: Why-not-X contrasts. Audience: Reviewers and contributors. Guarantees: Contrasts are explicit. Non-Goals: Full survey. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"externalization/why_not_x/#overview","title":"Overview","text":"<p>This doc lists explicit contrasts. Architecture context lives in Architecture. MPI context lives in Mpi.  </p>"},{"location":"externalization/why_not_x/#contracts","title":"Contracts","text":"<p>Workflow engines focus on orchestration, while this system focuses on bounded state transitions. Classic MAS frameworks optimize global coordination, while this system enforces local contracts. End-to-end LLM agents blur control, while this system enforces regulator boundaries.  </p>"},{"location":"externalization/why_not_x/#invariants","title":"Invariants","text":"<p>Contrasts align with Core. Contrasts align with Execution Model. Evidence aligns with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"externalization/why_not_x/#failure-modes","title":"Failure Modes","text":"<p>Missing contrasts weakens reviewability. Contrast drift breaks Core. Unlinked usage breaks Docs Style.  </p>"},{"location":"externalization/why_not_x/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Surface Area.  </p>"},{"location":"externalization/why_not_x/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when contrasts are encoded. The replacement is Core. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/anti_patterns/","title":"anti_patterns","text":"<p>Scope: Non-agentic anti-patterns. Audience: Contributors and reviewers. Guarantees: Anti-patterns are explicit and rejected. Non-Goals: Exhaustive catalog. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/anti_patterns/#overview","title":"Overview","text":"<p>This doc lists rejected patterns. Anti-patterns align with Core. Architecture context lives in Architecture.  </p>"},{"location":"governance/anti_patterns/#contracts","title":"Contracts","text":"<p>Direct state mutation bypasses src/agentic_proteins/biology/protein_agent.py. Hidden stochastic paths violate Invariants. Undeclared transitions violate src/agentic_proteins/biology/validation.py.  </p>"},{"location":"governance/anti_patterns/#invariants","title":"Invariants","text":"<p>Agent behavior stays within Core Concepts. Transition rules align with Execution Model. Checks align with tests/unit/test_protein_agent.py.  </p>"},{"location":"governance/anti_patterns/#failure-modes","title":"Failure Modes","text":"<p>Bypass attempts break Invariants. Silent changes break Core. Drift detection aligns with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/anti_patterns/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Extension checks align with tests/unit/test_module_stability.py. Extension docs align with Docs Style.  </p>"},{"location":"governance/anti_patterns/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when anti-patterns are encoded. The replacement is Invariants. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/biology/protein_agent.py.  </p>"},{"location":"governance/core/","title":"core","text":"<p>Scope: Non-negotiable core definition. Audience: Contributors and reviewers. Guarantees: Core meaning does not drift. Non-Goals: Feature rationale. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/core/#overview","title":"Overview","text":"<p>This doc defines the immutable core. Core terms align with Core Concepts. Architecture context lives in Architecture.  </p>"},{"location":"governance/core/#contracts","title":"Contracts","text":"<p>Core meaning binds agent, pathway, and cell roles. Contract locks live in Invariants. Evidence uses tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/core/#invariants","title":"Invariants","text":"<p>Core meaning stays fixed across releases. Core meaning aligns with Invariants. Evidence aligns with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/core/#failure-modes","title":"Failure Modes","text":"<p>Core drift breaks Invariants. Untracked changes break Core Concepts. Missing evidence breaks Docs Style.  </p>"},{"location":"governance/core/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Extension rules align with Docs Style. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"governance/core/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when the core is encoded. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/positioning/","title":"positioning","text":"<p>Scope: Final positioning choice. Audience: Reviewers and contributors. Guarantees: Position is explicit. Non-Goals: Market analysis. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/positioning/#overview","title":"Overview","text":"<p>This doc defines the final positioning. Architecture context lives in Architecture. Vocabulary aligns with Core Concepts.  </p>"},{"location":"governance/positioning/#contracts","title":"Contracts","text":"<p>Positioning is agent systems research. Computational biology context is modeled, not claimed as primary. Hybrid simulation framing is limited to pathway execution. Evidence uses tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/positioning/#invariants","title":"Invariants","text":"<p>Positioning stays fixed across releases. Positioning aligns with Core. Evidence aligns with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/positioning/#failure-modes","title":"Failure Modes","text":"<p>Ambiguous positioning weakens reviewability. Position drift breaks Core. Missing evidence breaks Docs Style.  </p>"},{"location":"governance/positioning/#extension-points","title":"Extension Points","text":"<p>Position updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"governance/positioning/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when positioning is encoded. The replacement is Core. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/public_contract_freeze/","title":"public-contract-freeze","text":"<p>Scope: Public contract stability. Audience: Maintainers and integrators. Guarantees: V1 API and CLI semantics are frozen. Non-Goals: Feature roadmap or implementation detail. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/public_contract_freeze/#decision","title":"Decision","text":"<p>The v1 public contract is frozen. This includes CLI commands, API schemas, and the semantics described in the docs.  </p>"},{"location":"governance/public_contract_freeze/#policy","title":"Policy","text":"<p>Any breaking change to v1 behavior requires a v2 release. No silent or implicit changes are allowed.  </p>"},{"location":"governance/public_contract_freeze/#enforcement","title":"Enforcement","text":"<p>Contract changes must be reviewed as governance decisions, not convenience patches.  </p>"},{"location":"governance/release_identity/","title":"release_identity","text":"<p>Scope: Release identity selection. Audience: Reviewers and contributors. Guarantees: Identity is explicit. Non-Goals: Marketing framing. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/release_identity/#overview","title":"Overview","text":"<p>This doc defines the release identity. Positioning context lives in Positioning. Version context lives in Semver.  </p>"},{"location":"governance/release_identity/#contracts","title":"Contracts","text":"<p>Release identity is research prototype. Identity aligns with Core. Evidence aligns with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/release_identity/#invariants","title":"Invariants","text":"<p>Identity stays fixed across releases. Identity aligns with Positioning. Identity aligns with Semver.  </p>"},{"location":"governance/release_identity/#failure-modes","title":"Failure Modes","text":"<p>Ambiguity breaks reviewability. Identity drift breaks Core. Unlinked usage breaks Docs Style.  </p>"},{"location":"governance/release_identity/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Review rules align with Triage. MPI changes align with Surface Area.  </p>"},{"location":"governance/release_identity/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when identity is encoded. The replacement is Core. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"governance/roadmap_ceiling/","title":"roadmap_ceiling","text":"<p>Scope: Research roadmap ceiling. Audience: Contributors and reviewers. Guarantees: Out-of-scope areas are explicit. Non-Goals: Feature backlog. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/roadmap_ceiling/#overview","title":"Overview","text":"<p>This doc states explicit research ceilings. Ceilings align with Core. Architecture context lives in Architecture.  </p>"},{"location":"governance/roadmap_ceiling/#contracts","title":"Contracts","text":"<p>The system avoids unsupervised topology mutation. The system avoids hidden state mutation in src/agentic_proteins/biology/protein_agent.py. The system avoids replacing contract locks in src/agentic_proteins/core/api_lock.py.  </p>"},{"location":"governance/roadmap_ceiling/#invariants","title":"Invariants","text":"<p>Ceilings align with Invariants. Ceilings align with Experimental. Checks align with tests/unit/test_core_api_lock.py.  </p>"},{"location":"governance/roadmap_ceiling/#failure-modes","title":"Failure Modes","text":"<p>Scope drift breaks Core. Implicit expansion breaks Invariants. Untracked changes break Docs Style.  </p>"},{"location":"governance/roadmap_ceiling/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Extension docs align with Docs Style. Extension checks align with tests/unit/test_module_stability.py.  </p>"},{"location":"governance/roadmap_ceiling/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when scope is encoded. The replacement is Core. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/core/api_lock.py.  </p>"},{"location":"governance/semver/","title":"semver","text":"<p>Scope: Semantic version meaning. Audience: Contributors and reviewers. Guarantees: Version semantics are explicit. Non-Goals: Release tooling. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"governance/semver/#overview","title":"Overview","text":"<p>This doc defines semantic version meaning. Version meaning aligns with Core. Release history is tracked in ../CHANGELOG.md.  </p>"},{"location":"governance/semver/#contracts","title":"Contracts","text":"<p>MAJOR means semantic model change. MINOR means new capability without meaning shift. PATCH means bug fix only.  </p>"},{"location":"governance/semver/#invariants","title":"Invariants","text":"<p>Version changes align with Invariants. Contract locks align with src/agentic_proteins/core/api_lock.py. Checks align with tests/unit/test_core_api_lock.py.  </p>"},{"location":"governance/semver/#failure-modes","title":"Failure Modes","text":"<p>Meaning drift breaks Core. Mismatched versions break ../CHANGELOG.md. Untracked changes break Invariants.  </p>"},{"location":"governance/semver/#extension-points","title":"Extension Points","text":"<p>Extensions follow Experimental. Extension checks align with tests/unit/test_module_stability.py. Extension docs align with Docs Style.  </p>"},{"location":"governance/semver/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when versioning is generated. The replacement is Docs Style. Obsolete docs are removed.  </p> <p>Code refs: src/agentic_proteins/core/api_lock.py.  </p>"},{"location":"interface/cli_surface/","title":"cli_surface","text":"<p>Scope: CLI surface list. Audience: Contributors and reviewers. Guarantees: Surface list matches click definitions. Non-Goals: Usage examples. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"interface/cli_surface/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Cli before edits. Read Docs Style for context.  </p>"},{"location":"interface/cli_surface/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/unit/test_cli_surface_documentation.py. Contracts link to Cli and Docs Style. - api - api serve - compare - export-report - inspect-candidate - reproduce - resume - run - --artifacts-dir - --dry-run - --execution-mode - --fasta - --host - --json - --no-docs - --no-logs - --output - --port - --pretty - --provider - --reload - --rounds - --sequence  </p>"},{"location":"interface/cli_surface/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/unit/test_cli_surface_documentation.py. Invariants align with Cli.  </p>"},{"location":"interface/cli_surface/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/unit/test_cli_surface_documentation.py. Failures align with Docs Style.  </p>"},{"location":"interface/cli_surface/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Cli. Extensions align with tests/unit/test_cli_surface_documentation.py.  </p>"},{"location":"interface/cli_surface/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_cli_surface_documentation.py.  </p>"},{"location":"meta/DOCS_STYLE/","title":"DOCS_STYLE","text":"<p>Scope: Documentation style contract for docs/. Audience: Contributors editing docs. Guarantees: Docs follow a single structure and voice. Non-Goals: Narrative guidance, marketing, or philosophy. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"meta/DOCS_STYLE/#overview","title":"Overview","text":"<p>This doc defines the documentation structure. Architecture components are defined in Architecture. Read Docs Voice for voice rules. Read Triage for lifecycle rules.  </p>"},{"location":"meta/DOCS_STYLE/#contracts","title":"Contracts","text":"<p>Section order is Overview, Contracts, Invariants, Failure Modes, Extension Points, Exit Criteria. Allowed section names match the order list. Max section depth is H2.  </p>"},{"location":"meta/DOCS_STYLE/#invariants","title":"Invariants","text":"<p>Each doc has the front-matter block. Each section has three sentences or a table. Each doc links to two docs and one code artifact.  </p>"},{"location":"meta/DOCS_STYLE/#failure-modes","title":"Failure Modes","text":"<p>Style violations fail docs lint. Style violations block CI. Style violations require a rewrite.  </p>"},{"location":"meta/DOCS_STYLE/#extension-points","title":"Extension Points","text":"<p>Style changes occur in this file. Style changes update scripts/check_docs_consistency.py. Style changes update Docs Voice.  </p>"},{"location":"meta/DOCS_STYLE/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when docs are generated. The replacement is scripts/check_docs_consistency.py. Obsolete docs are removed.  </p> <p>Code refs: scripts/check_docs_consistency.py.  </p>"},{"location":"meta/DOCS_VOICE/","title":"DOCS_VOICE","text":"<p>Scope: Documentation voice rules. Audience: Contributors writing docs. Guarantees: Voice rules are enforced by CI. Non-Goals: Copywriting advice. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"meta/DOCS_VOICE/#overview","title":"Overview","text":"<p>This doc defines the documentation voice. Architecture components are defined in Architecture. Read Docs Style before edits. Read Naming for naming context.  </p>"},{"location":"meta/DOCS_VOICE/#contracts","title":"Contracts","text":"<p>Tense is present and declarative. Person is impersonal and system-centric. Sentence length is limited to twenty words.  </p>"},{"location":"meta/DOCS_VOICE/#invariants","title":"Invariants","text":"<p>Marketing language is forbidden. Opinion and hedging language is forbidden. Narrative framing is forbidden.  </p>"},{"location":"meta/DOCS_VOICE/#failure-modes","title":"Failure Modes","text":"<p>Voice violations fail docs lint. Voice violations block CI. Voice violations require a rewrite.  </p>"},{"location":"meta/DOCS_VOICE/#extension-points","title":"Extension Points","text":"<p>Voice rules change only in this file. Voice changes update scripts/check_docs_consistency.py. Voice changes update Docs Style.  </p>"},{"location":"meta/DOCS_VOICE/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when docs are generated. The replacement is scripts/check_docs_consistency.py. Obsolete docs are removed.  </p> <p>Code refs: scripts/check_docs_consistency.py.  </p>"},{"location":"meta/NAMING/","title":"NAMING","text":"<p>Scope: Canonical naming registry. Audience: Contributors and reviewers. Guarantees: Names and casing are enforced. Non-Goals: Domain theory. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"meta/NAMING/#overview","title":"Overview","text":"<p>This doc defines canonical names. Architecture components are defined in Architecture. Read Docs Style before edits. Read Docs Voice for voice rules.  </p>"},{"location":"meta/NAMING/#contracts","title":"Contracts","text":"<p>Canonical names are listed below. Forbidden aliases are listed below. Capitalization follows the canonical list.  </p>"},{"location":"meta/NAMING/#invariants","title":"Invariants","text":"<p>Each concept has one canonical name. Aliases are rejected in docs. Casing is enforced by CI.  </p>"},{"location":"meta/NAMING/#failure-modes","title":"Failure Modes","text":"<p>Alias usage fails docs lint. Casing drift fails docs lint. Undefined names fail reviews.  </p>"},{"location":"meta/NAMING/#extension-points","title":"Extension Points","text":"<p>Naming changes occur in this file. Naming changes update scripts/check_docs_consistency.py. Naming changes update Triage.  </p>"},{"location":"meta/NAMING/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when naming is generated. The replacement is scripts/check_docs_consistency.py. Obsolete docs are removed.  </p> <p>Canonical names: - CLI - API - run_id - artifacts - agent - tool - policy - execution unit - evaluation artifact - protein - signal - pathway - regulation - cell  </p> <p>Forbidden aliases: - command line - endpoint - run id - artifact directory - execution-unit - evaluation output  </p> <p>Code refs: scripts/check_docs_consistency.py.  </p>"},{"location":"meta/SPINE/","title":"SPINE","text":"<p>Scope: Single navigation spine for docs/. Audience: Readers consuming docs top-down. Guarantees: Lists all docs in order. Non-Goals: Per-topic READMEs. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"meta/SPINE/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Index before edits. Read Docs Style for context.  </p>"},{"location":"meta/SPINE/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with mkdocs.yml. Contracts link to Index and Docs Style.  </p>"},{"location":"meta/SPINE/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with mkdocs.yml. Invariants align with Index.  </p>"},{"location":"meta/SPINE/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with mkdocs.yml. Failures align with Docs Style.  </p>"},{"location":"meta/SPINE/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Index. Extensions align with mkdocs.yml.  </p>"},{"location":"meta/SPINE/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_docs_contract.py. Docs list: - Docs Style - Docs Voice - Naming - Triage - Spine - Index - Getting Started - Core Concepts - Core - Semver - Anti Patterns - Roadmap Ceiling - Positioning - Release Identity - Agentic Criteria - Agent Taxonomy - Formal Model - Falsifiable Claim - Decisive Experiment - Ablation Studies - Neutral Results - Reviewer Premortem - System Schematic - Mpi - Golden Path - Misuse Guards - Surface Area - Sandbox - Invariant Visualization - Why Not X - Architecture - Invariants - Experimental - Llm Authority - Execution Model - Execution Lifecycle - Design Debt - Cli - Cli Surface - Overview - Schema - Dependencies - Threat Model - Citation </p>"},{"location":"meta/TRIAGE/","title":"TRIAGE","text":"<p>Scope: Triage rules for documentation lifecycle. Audience: Contributors deciding doc changes. Guarantees: Docs exist only when tied to code. Non-Goals: Content authoring guidance. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"meta/TRIAGE/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Docs Style before edits. Read Spine for context.  </p>"},{"location":"meta/TRIAGE/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/unit/test_docs_contract.py. Contracts link to Docs Style and Spine.  </p>"},{"location":"meta/TRIAGE/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/unit/test_docs_contract.py. Invariants align with Docs Style.  </p>"},{"location":"meta/TRIAGE/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/unit/test_docs_contract.py. Failures align with Spine.  </p>"},{"location":"meta/TRIAGE/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Docs Style. Extensions align with tests/unit/test_docs_contract.py.  </p>"},{"location":"meta/TRIAGE/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Spine. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_docs_contract.py.  </p>"},{"location":"overview/audience/","title":"audience","text":"<p>Scope: Fit and misuse warnings. Audience: Prospective adopters. Guarantees: Clear fit boundaries. Non-Goals: Onboarding details. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/audience/#who-this-is-for","title":"Who This Is For","text":"<ul> <li>Researchers who need deterministic, replayable execution.  </li> <li>Platform teams enforcing audit-ready agent workflows.  </li> <li>Operators who must explain why runs diverged.  </li> </ul>"},{"location":"overview/audience/#who-this-is-not-for","title":"Who This Is Not For","text":"<ul> <li>Teams looking for a general chat framework.  </li> <li>Product builders optimizing for rapid prototyping over rigor.  </li> <li>Users who want silent retries or hidden randomness.  </li> </ul>"},{"location":"overview/audience/#warning","title":"Warning","text":"<p>If you want a forgiving system that hides nondeterminism, this will feel strict and slow. That is intentional.  </p>"},{"location":"overview/audit-grade/","title":"Audit-Grade","text":"<p>What constitutes audit-grade evidence in this system.</p>"},{"location":"overview/audit-grade/#sufficient-artifacts","title":"Sufficient artifacts","text":"<p>Audit-grade evidence consists of the persisted execution trace, the resolved plan, declared policies, and the dataset descriptor with DVC identity. These artifacts establish what ran, under which rules, and with which inputs. If any of these are missing, audit-grade status is not met.</p>"},{"location":"overview/audit-grade/#intentionally-excluded","title":"Intentionally excluded","text":"<p>Runtime memory, ephemeral caches, and live tool sessions are intentionally excluded from audit evidence. They are not stable, not replayable, and not part of the contract. Their absence is deliberate and should not be interpreted as incomplete persistence.</p>"},{"location":"overview/audit-grade/#auditor-inference-limits","title":"Auditor inference limits","text":"<p>Auditors can verify that recorded events and artifacts match declared contracts and replay acceptability. They cannot infer hidden randomness, unstated external inputs, or undeclared dataset changes. Audit conclusions are bounded by what is explicitly persisted.</p>"},{"location":"overview/boring-path/","title":"boring-path","text":"<p>Scope: Single end-to-end example. Audience: Users validating the simplest workflow. Guarantees: One deterministic run and replay. Non-Goals: Advanced features or optimizations. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/boring-path/#overview","title":"Overview","text":"<p>This is the boring path: one flow, one agent, deterministic replay, DuckDB-backed, using both CLI and API.  </p>"},{"location":"overview/boring-path/#files","title":"Files","text":"<ul> <li><code>examples/boring/flow.json</code> </li> <li><code>examples/boring/policy.json</code> </li> </ul>"},{"location":"overview/boring-path/#cli","title":"CLI","text":"<pre><code>agentic-flows run examples/boring/flow.json --policy examples/boring/policy.json --db-path /tmp/flows.duckdb\nagentic-flows replay examples/boring/flow.json --policy examples/boring/policy.json --run-id &lt;run_id&gt; --tenant-id tenant-a --db-path /tmp/flows.duckdb\nagentic-flows inspect run &lt;run_id&gt; --tenant-id tenant-a --db-path /tmp/flows.duckdb\n</code></pre>"},{"location":"overview/boring-path/#api","title":"API","text":"<pre><code>curl -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-Agentic-Gate: gate-boring\" \\\n  -H \"X-Determinism-Level: strict\" \\\n  -H \"X-Policy-Fingerprint: &lt;policy_fingerprint&gt;\" \\\n  -d '{\"flow_manifest\":\"file://examples/boring/flow.json\",\"inputs_fingerprint\":\"&lt;inputs_fingerprint&gt;\",\"run_mode\":\"live\",\"dataset_id\":\"retrieval_corpus\",\"policy_fingerprint\":\"&lt;policy_fingerprint&gt;\"}' \\\n  http://127.0.0.1:8000/api/v1/flows/run\n\ncurl -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-Agentic-Gate: gate-boring\" \\\n  -H \"X-Determinism-Level: strict\" \\\n  -H \"X-Policy-Fingerprint: &lt;policy_fingerprint&gt;\" \\\n  -d '{\"run_id\":\"&lt;run_id&gt;\",\"expected_plan_hash\":\"&lt;plan_hash&gt;\",\"acceptability_threshold\":\"exact_match\",\"observer_mode\":false}' \\\n  http://127.0.0.1:8000/api/v1/flows/replay\n</code></pre>"},{"location":"overview/cli-contract/","title":"CLI Contract","text":"<p>Exit code semantics for operator usage.</p> <p>Exit code 0 means the command completed successfully under declared contracts. Exit code 1 means the command failed due to a contract violation or runtime failure. Exit code 2 means the command was invoked incorrectly or with invalid arguments.</p>"},{"location":"overview/cli-contract/#environment","title":"Environment","text":"<ul> <li><code>AGENTIC_FLOWS_STRICT=1</code> forbids best-effort modes and enforces strict determinism.</li> </ul>"},{"location":"overview/common-misuse/","title":"Common Misuse","text":"<p>Frequent incorrect assumptions that break guarantees.</p> <ul> <li>Users assume runs can be replayed without the original dataset; that is wrong because dataset identity is part of the contract; bypassing it breaks replay acceptance.</li> <li>Users assume nondeterministic tools are acceptable without explicit authorization; that is wrong because entropy must be declared; ignoring it breaks determinism guarantees.</li> <li>Users assume partial traces can be treated as completed runs; that is wrong because finalization is required; skipping it breaks audit integrity.</li> <li>Users assume CLI output is a stable API; that is wrong because only contracts are stable; relying on output breaks compatibility expectations.</li> <li>Users assume environment changes are harmless; that is wrong because fingerprints must match; drifting environments break replay validation.</li> </ul>"},{"location":"overview/datasets/","title":"Datasets","text":"<p>Dataset immutability rules.</p> <p>datasets are append-only. mutations break replay guarantees. DVC is mandatory for persistence.</p>"},{"location":"overview/dependencies/","title":"Dependencies","text":"<p>Inventory of bijux dependencies and their declared roles.</p> Dependency PyPI availability Stability status Required for bijux-cli unknown unknown core bijux-agent unknown unknown core bijux-rag unknown unknown core bijux-rar unknown unknown core bijux-vex unknown unknown core"},{"location":"overview/determinism/","title":"Determinism","text":"<p>Determinism boundaries for execution and replay guarantees.</p>"},{"location":"overview/determinism/#what-determinism-means-here","title":"What determinism means here","text":"<p>Determinism means identical inputs, declared policies, and persisted contracts produce the same replay envelope and verification outcomes across runs.</p>"},{"location":"overview/determinism/#sources-of-allowed-nondeterminism","title":"Sources of allowed nondeterminism","text":"<p>Allowed nondeterminism is restricted to explicitly authorized entropy sources that are budgeted, recorded, and reflected in the replay acceptability policy.</p>"},{"location":"overview/determinism/#what-determinism-does-not-cover","title":"What determinism does NOT cover","text":"<ul> <li>hardware differences</li> <li>floating-point drift</li> <li>external API nondeterminism</li> <li>non-deterministic operating system scheduling</li> <li>manual data edits outside declared datasets</li> </ul>"},{"location":"overview/determinism/#what-causes-replay-failure","title":"What causes replay failure","text":"<p>Replay fails when contract fingerprints, dataset identity, environment fingerprints, or acceptability thresholds diverge from the recorded run.</p>"},{"location":"overview/documentation-policy/","title":"Documentation Policy","text":"<p>Docstring and contract coverage policy.</p> <p>Internal docstrings are sparse by design to avoid duplicating contract sources. Contracts and tests are the source of truth for behavior and guarantees. Docstring coverage percentages do not reflect correctness or safety here. We prioritize enforceable contracts over narrative documentation.</p>"},{"location":"overview/getting_started/","title":"getting_started","text":"<p>Scope: Single install and run path. Audience: Users running the CLI. Guarantees: One reproducible path with fixed assumptions. Non-Goals: Alternative setups or options. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/getting_started/#overview","title":"Overview","text":"<p>Getting started defines one install and run path. Read Core Concepts for vocabulary. Read Dependencies for dependency constraints.  Architecture components are defined in Architecture.  </p>"},{"location":"overview/getting_started/#contracts","title":"Contracts","text":"<p>Install with <code>pipx install agentic-proteins</code>. Run with <code>agentic-proteins run --sequence \"ACDEFGHIKLMNPQRSTVWY\"</code>. Artifacts are stored under <code>artifacts/&lt;run_id&gt;/</code>.  </p>"},{"location":"overview/getting_started/#invariants","title":"Invariants","text":"<p>Local filesystem permissions prevent cross-tenant access. Providers return deterministic results for fixed inputs. CI artifacts are not tampered with between steps.  </p>"},{"location":"overview/getting_started/#failure-modes","title":"Failure Modes","text":"<p>Missing allowlist dependencies in Dependencies break this path.  Assumptions are tracked in Threat Model.  Invalid sequences fail validation.  </p>"},{"location":"overview/getting_started/#extension-points","title":"Extension Points","text":"<p>Changes update Cli. Dependency changes update Dependencies.  Vocabulary changes update Core Concepts.  </p>"},{"location":"overview/getting_started/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when a generated entrypoint replaces it. The replacement is Index. Obsolete docs are removed.  </p> <p>Code refs: tests/integration/test_cli.py.  </p>"},{"location":"overview/mental-model/","title":"mental-model","text":"<p>Scope: Core execution mental model. Audience: New readers. Guarantees: One shared mental model. Non-Goals: Implementation detail. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/mental-model/#overview","title":"Overview","text":"<p>Think of a run as a flow that decomposes into ordered steps, each emitting events that become artifacts, and those artifacts define replay.  </p> <pre><code>Flow \u2192 Steps \u2192 Events \u2192 Artifacts \u2192 Replay\n</code></pre> <p>If you can explain that chain, you can explain the system.  </p>"},{"location":"overview/minimal-run/","title":"minimal-run","text":"<p>Scope: Smallest end-to-end walkthrough. Audience: Users validating behavior. Guarantees: One traceable run with replay and diff. Non-Goals: Full feature coverage. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/minimal-run/#overview","title":"Overview","text":"<p>This walkthrough uses one flow, one agent, one retrieval, and one verification failure to show the full lifecycle: run \u2192 persist \u2192 replay \u2192 diff.  </p>"},{"location":"overview/minimal-run/#flow","title":"Flow","text":"<p>The flow has a single step that calls one agent, performs one retrieval, and emits reasoning that fails a verification gate.  </p>"},{"location":"overview/minimal-run/#run","title":"Run","text":"<pre><code>agentic-flows run examples/minimal/flow.json --db-path /tmp/flows.duckdb\n</code></pre>"},{"location":"overview/minimal-run/#persist","title":"Persist","text":"<p>The run persists automatically to DuckDB at the provided path.  </p>"},{"location":"overview/minimal-run/#replay","title":"Replay","text":"<pre><code>agentic-flows inspect run &lt;run_id&gt; --tenant-id &lt;tenant&gt; --db-path /tmp/flows.duckdb\n</code></pre>"},{"location":"overview/minimal-run/#diff","title":"Diff","text":"<pre><code>agentic-flows diff run &lt;run_a&gt; &lt;run_b&gt; --tenant-id &lt;tenant&gt; --db-path /tmp/flows.duckdb\n</code></pre>"},{"location":"overview/minimal-run/#verification-failure","title":"Verification Failure","text":"<p>This flow triggers a verification failure because the retrieved evidence contradicts the reasoning claim. The diff surfaces the verification conflict instead of accepting the run.  </p>"},{"location":"overview/non-determinism-contract/","title":"Non-Determinism Contract","text":"<p>This system allows non-determinism only when it is declared, bounded, and approved by policy. If you want randomness, you must ask for it explicitly and stay inside the guardrails.</p>"},{"location":"overview/non-determinism-contract/#allowed","title":"Allowed","text":"<ul> <li>Declared non-determinism intent with a source, magnitude range, and justification.</li> <li>Declared entropy budgets that bound magnitude per source.</li> <li>Replay modes that state how divergence is evaluated (strict, bounded, observational).</li> </ul>"},{"location":"overview/non-determinism-contract/#forbidden","title":"Forbidden","text":"<ul> <li>Entropy without a declared intent.</li> <li>Entropy sources not listed in the policy or budget.</li> <li>Entropy magnitudes outside the declared range.</li> </ul>"},{"location":"overview/non-determinism-contract/#governance","title":"Governance","text":"<ul> <li>A non-determinism policy runs before execution.</li> <li>Policy violations hard-fail the run.</li> <li>Budget exhaustion triggers the configured action (halt, degrade, or mark non-certifiable).</li> </ul>"},{"location":"overview/non-determinism-contract/#guarantees-that-still-hold","title":"Guarantees That Still Hold","text":"<ul> <li>Dataset identity, plan hash, and environment fingerprints are enforced.</li> <li>Replay acceptability is still validated against declared thresholds.</li> <li>Determinism profiles and entropy records are persisted for audit.</li> </ul>"},{"location":"overview/non-determinism-contract/#intentionally-not-guaranteed","title":"Intentionally Not Guaranteed","text":"<ul> <li>Bit-for-bit replay for flows that declare stochastic sources.</li> <li>Global determinism when any step opts into entropy.</li> <li>Replay acceptance without a policy that permits the observed variance.</li> </ul>"},{"location":"overview/non-goals/","title":"Non-goals","text":"<p>Boundaries for what this project explicitly does not provide.</p> <ul> <li>not a chat framework</li> <li>not autonomous agents</li> <li>not interactive / low-latency</li> <li>not a prompt playground</li> <li>not a vector database replacement</li> <li>not a general-purpose orchestration engine</li> </ul>"},{"location":"overview/relationship-to-agentic-proteins/","title":"relationship-to-agentic-proteins","text":"<p>Scope: Comparison to agentic-proteins. Audience: Readers familiar with both projects. Guarantees: Explicit similarities and differences. Non-Goals: Marketing claims. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/relationship-to-agentic-proteins/#shared-philosophy","title":"Shared Philosophy","text":"<p>Both projects enforce determinism, provenance, and audit-ready outputs. Both treat invariants as non-negotiable contracts, not optional best practices.  </p>"},{"location":"overview/relationship-to-agentic-proteins/#intentional-differences","title":"Intentional Differences","text":"<p>Agentic-proteins focuses on protein design workflows and domain-specific artifacts. Agentic-flows generalizes the same execution guarantees to broader agent workflows and replayable traces.  </p>"},{"location":"overview/relationship-to-agentic-proteins/#comparison","title":"Comparison","text":"Area agentic-proteins agentic-flows Scope Protein design runtime General execution and replay framework Artifacts Domain-specific design artifacts Cross-domain execution artifacts Primary users Bio design teams Research and platform teams CLI focus Design-centric commands Flow, replay, and diff commands Contracts Protein-domain invariants Execution invariants across agents"},{"location":"overview/release-checklist/","title":"Release Checklist (v0.1.0)","text":"<p>Release seal: closure, alignment, and declaration only.</p>"},{"location":"overview/release-checklist/#1-freeze-scope-absolute","title":"1. Freeze scope (absolute)","text":"<ul> <li>Only clarification, hardening, or removal allowed.</li> <li>No new APIs.</li> <li>No new policy semantics.</li> <li>No new execution paths.</li> <li>No refactors unless required for correctness.</li> <li>Any observable behavior change defers to v0.2.0.</li> </ul>"},{"location":"overview/release-checklist/#2-align-versioning-with-agentic-proteins-dynamic-only","title":"2. Align versioning with agentic-proteins (dynamic only)","text":"<ul> <li>Versioning derives from VCS tags; no static version fields.</li> <li>Tagged builds must not include .dev or local suffixes.</li> <li><code>git tag v0.1.0</code> is the source of truth for artifacts.</li> </ul>"},{"location":"overview/release-checklist/#3-align-project-metadata-with-agentic-proteins","title":"3. Align project metadata with agentic-proteins","text":"<ul> <li>Metadata is crisp, technical, and non-marketing.</li> <li>Description explicitly mentions governed non-deterministic execution.</li> <li>Keywords are concrete and searchable.</li> <li>Classifiers reflect current maturity (no production/stable claims).</li> </ul>"},{"location":"overview/release-checklist/#4-declare-non-determinism-status-once-clearly","title":"4. Declare non-determinism status (once, clearly)","text":"<ul> <li>Canonical statement present in README and docs entry point only.</li> </ul>"},{"location":"overview/release-checklist/#5-eliminate-misleading-or-dead-surfaces","title":"5. Eliminate misleading or dead surfaces","text":"<ul> <li>No legacy paths, shims, or compatibility placeholders.</li> <li>No unused CLI flags.</li> <li>No undocumented environment variables.</li> <li>No placeholder policy presets exposed publicly.</li> <li>No commented-out or \u201cfuture\u201d code paths.</li> </ul>"},{"location":"overview/release-checklist/#6-lock-api-guarantees-to-schema-only","title":"6. Lock API guarantees to schema only","text":"<ul> <li>OpenAPI schema is frozen for v0.1.0.</li> <li>Schema compatibility is the only API guarantee.</li> <li>Runtime behavior, policy interpretation, and enforcement may evolve.</li> </ul>"},{"location":"overview/release-checklist/#7-normalize-failure-language-and-taxonomy","title":"7. Normalize failure language and taxonomy","text":"<ul> <li>CLI output, API errors, replay verdicts, and verification failures map to named failure classes.</li> <li>Reasons are deterministic, inspectable, and auditable.</li> <li>No apologetic or speculative phrasing.</li> </ul>"},{"location":"overview/release-checklist/#8-write-release-notes-one-page-hard-truth","title":"8. Write release notes (one page, hard truth)","text":"<ul> <li>Structure: What it is / What it is not / Who it is for / What comes next.</li> <li>No hype, no roadmap, no promises.</li> </ul>"},{"location":"overview/release-checklist/#9-final-artifact-hygiene","title":"9. Final artifact hygiene","text":"<ul> <li>Final artifacts only: wheel, sdist, SBOM (prod + dev), citation outputs, OpenAPI schema, test + API JUnit reports.</li> <li>Remove intermediate builds, local-only outputs, and .dev artifacts.</li> </ul>"},{"location":"overview/release-checklist/#10-agentic-flows-help-must-succeed","title":"10. <code>agentic-flows --help</code> must succeed","text":"<ul> <li>Must work without editable installs, dev extras, local paths, or hidden assumptions.</li> </ul>"},{"location":"overview/release-notes-v0.1.0/","title":"v0.1.0 Release Notes","text":""},{"location":"overview/release-notes-v0.1.0/#what-it-is","title":"What it is","text":"<ul> <li>A governed execution and replay substrate with auditable non-determinism controls.</li> <li>A contract-first system with schema-defined surfaces and traceable run data.</li> </ul>"},{"location":"overview/release-notes-v0.1.0/#what-it-is-not","title":"What it is not","text":"<ul> <li>A stability promise or backward compatible API line.</li> <li>A mature probabilistic reasoning framework.</li> </ul>"},{"location":"overview/release-notes-v0.1.0/#who-it-is-for","title":"Who it is for","text":"<ul> <li>Engineers and researchers who need reproducible execution, replay analysis, and audit trails.</li> <li>Teams validating agent workflows under explicit determinism and entropy constraints.</li> </ul>"},{"location":"overview/release-notes-v0.1.0/#what-comes-next","title":"What comes next","text":"<ul> <li>Stabilization of runtime enforcement and replay semantics.</li> <li>Narrow, test-backed surface expansions aligned with schema guarantees.</li> </ul>"},{"location":"overview/replay-equivalence/","title":"Replay Equivalence","text":"<p>Definition of replay equivalence boundaries.</p>"},{"location":"overview/replay-equivalence/#bitwise-equivalence","title":"Bitwise equivalence","text":"<p>Bitwise equivalence means identical persisted artifacts and events at the byte level. It requires the same ordering, timestamps, and serialized payloads. Any single-byte difference is a replay failure. This is the strictest check and is rarely achievable outside controlled runs.</p>"},{"location":"overview/replay-equivalence/#semantic-equivalence","title":"Semantic equivalence","text":"<p>Semantic equivalence means the same declared contracts and outcomes hold, even if incidental bytes differ. It focuses on plan hashes, dataset identity, and verification outcomes. When semantic equivalence holds, replay remains acceptable for audit. It is the baseline for production acceptability when strict replay is not possible.</p>"},{"location":"overview/replay-equivalence/#acceptable-divergence","title":"Acceptable divergence","text":"<p>Acceptable divergence is a bounded deviation explicitly allowed by the replay acceptability policy. It requires that deviations are recorded and stay within declared thresholds. Divergence outside those bounds is always a replay rejection. Acceptable divergence does not expand over time or across versions.</p>"},{"location":"overview/stability/","title":"Stability","text":"<p>Stability boundaries for v1 users and integrators.</p>"},{"location":"overview/stability/#frozen-in-v1","title":"Frozen in v1","text":"<ul> <li>Public CLI commands: run, replay, inspect.</li> <li>API v1 schemas and required headers.</li> <li>Replay acceptability semantics and determinism classes.</li> </ul>"},{"location":"overview/stability/#may-change-without-notice","title":"May change without notice","text":"<ul> <li>Experimental CLI subcommands and output formatting.</li> <li>Internal storage layout and migration mechanics.</li> <li>Test fixtures and benchmarking thresholds.</li> </ul>"},{"location":"overview/stability/#requires-major-version-bump","title":"Requires major version bump","text":"<ul> <li>Any change that alters replay equivalence outcomes.</li> <li>Breaking changes to public CLI or API fields.</li> <li>Contract semantics for failure taxonomy.</li> </ul>"},{"location":"overview/storage-model/","title":"Storage Model","text":"<p>How persistence and dataset governance work together.</p> <p>DuckDB is used as the canonical store because it provides durable, queryable, and audited execution records in one place. It enables strict schema enforcement and replay comparisons without ad-hoc serialization. This keeps execution history consistent across runs and environments.</p> <p>DVC controls dataset identity, versioning, and immutability boundaries for replayable data. It is the single authority for dataset fingerprints and frozen artifacts. DuckDB records those identities but does not replace DVC as the dataset system of record.</p> <p>Bypassing DVC breaks dataset provenance, invalidates replay guarantees, and makes stored runs unverifiable. It also severs the link between persisted runs and the dataset contract. The system treats such runs as invalid for replay acceptance.</p>"},{"location":"overview/storage-model/#duckdb-execution-model","title":"DuckDB Execution Model","text":"<p>Operational guarantees you must respect.</p> <ul> <li>Single-writer: only one execution write store should hold the write lock per DB file at a time. Concurrent writers are undefined and may corrupt replay invariants.</li> <li>Advisory locking: the runtime relies on process-level coordination to avoid write conflicts. External orchestration must serialize writers.</li> <li>Replay isolation: replays read immutable traces. Do not mutate or vacuum historical tables between capture and replay.</li> </ul>"},{"location":"overview/terminology/","title":"Terminology","text":"<p>Binding vocabulary for this system.</p> <p>Flow: A declared, versioned plan for how a run should execute. Run: One execution attempt of a flow with a fixed configuration and recorded trace. Replay: Re-execution of a run using persisted inputs and envelopes to compare outcomes. Determinism: The degree to which replays should produce identical traces and artifacts. Acceptability: The policy threshold for deciding whether a replay divergence is allowed. Entropy: Any non-deterministic influence that must be declared and audited.</p>"},{"location":"overview/upgrade-policy/","title":"Upgrade Policy","text":"<p>Upgrade guardrail.</p> <p>If replay equivalence breaks, upgrade is forbidden.</p>"},{"location":"overview/versioning/","title":"Versioning","text":"<p>Rules for changes in the first public release.</p> <p>This is the first public release and the rules start here. v0.x carries no backward compatibility guarantees. Version is a capability signal, not a stability promise. Non-determinism semantics may evolve within v0.x. The git tag (e.g., v0.1.0) is the source of truth for versioning. Tagged builds must derive version exclusively from VCS metadata. MAJOR: any change that can alter replay equivalence, persisted schema, or public contracts. MINOR: additive, backward-compatible changes to public CLI, HTTP schema, or ontology values. PATCH: documentation fixes, refactors, or internal changes with identical behavior. Example PATCH: comment fixes or file moves with no API impact. Example MINOR: adding an optional response field or a new CLI flag that preserves defaults. Example MAJOR: changing determinism semantics, replay rules, or required fields.</p>"},{"location":"overview/what-breaks-determinism/","title":"What Breaks Determinism","text":"<p>Determinism failure modes and how the system treats them.</p> <ul> <li>Unseeded randomness; detected; mitigated by strict determinism checks that abort the run.</li> <li>Environment drift (dependency or OS changes); detected; mitigated by environment fingerprint mismatch failures.</li> <li>External API nondeterminism; detected when declared as entropy and budgeted, otherwise silent; mitigated only when authorized.</li> <li>Mutable datasets; detected; mitigated by dataset hash enforcement and replay mismatch failures.</li> <li>Human intervention outside declared scope; silent; not mitigated beyond audit logging.</li> </ul>"},{"location":"overview/why-agentic-flows/","title":"why-agentic-flows","text":"<p>Scope: Motivation for agentic-flows. Audience: Readers evaluating fit. Guarantees: States what agentic-flows enforces. Non-Goals: Marketing or competitive positioning. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"overview/why-agentic-flows/#overview","title":"Overview","text":"<p>Most agent frameworks optimize for speed and flexibility, then retroactively ask users to trust the results. The result is opaque runs, unverifiable outcomes, and systems that drift as soon as scale or team size increases.  </p> <p>Agentic-flows enforces determinism, provenance, and replayability as first-class guarantees. It treats execution as a contract, not a best-effort convenience, and makes divergence visible instead of silently accepted.  </p>"},{"location":"overview/why-agentic-flows/#non-goals","title":"Non-Goals","text":"<ul> <li>An agent runtime that prioritizes autonomous behavior over auditability.  </li> <li>A general-purpose chat or planning framework.  </li> <li>A best-effort system that accepts unverifiable outputs.  </li> </ul>"},{"location":"overview/why_agentic_flows/","title":"Why agentic-flows exists","text":"<p>Agentic-flows targets a gap that general agent frameworks leave open: auditable execution with explicit contracts, replayability, and invariant enforcement. Typical frameworks optimize for flexibility and rapid iteration, but they do not treat execution traces, datasets, and policy decisions as contractual artifacts. That makes it hard to prove what happened, why it happened, or whether a run can be reproduced under the same declared conditions.</p> <p>Determinism and replay are the core thesis because they turn execution into a verifiable record. A deterministic run with a replay envelope can be checked against stored traces, hashes, and policies without reinterpreting logs or inferring intent. This supports governance, debugging, and compliance workflows that require stable evidence rather than best-effort behavior.</p> <p>This system is not for teams seeking interactive chat UX, rapid prompt experimentation, or non-reproducible exploration. It is also not a general-purpose agent runtime or a planner framework; it assumes a contract-first model and emphasizes auditability over convenience. If you need adaptive behavior without strict replay guarantees, this is the wrong tool.</p>"},{"location":"overview/wont-support/","title":"Wont Support","text":"<p>Capabilities intentionally excluded from this system.</p> <ul> <li>interactive chat loops</li> <li>self-modifying agents</li> <li>autonomous goal creation</li> <li>implicit memory writes</li> <li>real-time streaming agents</li> <li>silent retries</li> </ul>"},{"location":"research/ablation_studies/","title":"ablation_studies","text":"<p>Scope: Ablation study matrix. Audience: Reviewers and contributors. Guarantees: Ablations are explicit. Non-Goals: Full experiment suite. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/ablation_studies/#overview","title":"Overview","text":"<p>This doc lists required ablations. Architecture context lives in Architecture. Claim context lives in Falsifiable Claim.  </p>"},{"location":"research/ablation_studies/#contracts","title":"Contracts","text":"<p>Each ablation removes one capability. Ablations compare recovery and failure metrics. Metrics follow Metrics. Evidence uses tests/regression/test_negative_results.py. | Ablation | Removed capability | Expected signal. | | --- | --- | --- | | No regulator | Proposal application | Recovery drop. | | No stochasticity | Noise in transitions | Variance drop. | | No recovery | Failure handling | Recovery drop. | | No constraints | Constraint checks | Failure rise. |  </p>"},{"location":"research/ablation_studies/#invariants","title":"Invariants","text":"<p>Ablation list stays fixed. List aligns with Core. Evidence aligns with tests/regression/test_negative_results.py.  </p>"},{"location":"research/ablation_studies/#failure-modes","title":"Failure Modes","text":"<p>Missing ablations weaken claims. List drift breaks Core. Missing evidence breaks Docs Style.  </p>"},{"location":"research/ablation_studies/#extension-points","title":"Extension Points","text":"<p>Ablation updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/ablation_studies/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when ablations are encoded. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_negative_results.py.  </p>"},{"location":"research/agent_taxonomy/","title":"agent_taxonomy","text":"<p>Scope: Mapping to agent taxonomies. Audience: Reviewers and contributors. Guarantees: Contrasts are explicit. Non-Goals: Exhaustive survey. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/agent_taxonomy/#overview","title":"Overview","text":"<p>This doc maps the system to known taxonomies. Architecture context lives in Architecture. Vocabulary aligns with Core Concepts.  </p>"},{"location":"research/agent_taxonomy/#contracts","title":"Contracts","text":"<p>BDI agents use belief, desire, intention loops. This system uses fixed transition rules instead of deliberation. Reactive agents use direct stimulus-response rules. This system adds constraints and failure states beyond direct reactions. MDP agents assume global policy optimization. This system uses local transition validation without global policy search. Multi-agent systems focus on interaction graphs. This system uses explicit signal scopes and pathway contracts.  </p>"},{"location":"research/agent_taxonomy/#invariants","title":"Invariants","text":"<p>Taxonomy mapping stays consistent. Mapping aligns with Invariants. Evidence aligns with tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/agent_taxonomy/#failure-modes","title":"Failure Modes","text":"<p>Unstated contrasts weaken reviewability. Drift in mapping breaks Core. Unlinked references break Docs Style.  </p>"},{"location":"research/agent_taxonomy/#extension-points","title":"Extension Points","text":"<p>Mapping updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/agent_taxonomy/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when mapping is encoded. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/agentic_criteria/","title":"agentic_criteria","text":"<p>Scope: Agentic criteria checklist. Audience: Reviewers and contributors. Guarantees: Checklist entries map to evidence. Non-Goals: Marketing claims. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/agentic_criteria/#overview","title":"Overview","text":"<p>This doc defines a checklist for agentic criteria. Architecture context lives in Architecture. Vocabulary aligns with Core Concepts.  </p>"},{"location":"research/agentic_criteria/#contracts","title":"Contracts","text":"<p>Checklist entries are fixed. Each entry maps to a test or artifact. Evidence is linked below. - Statefulness is verified in tests/unit/test_protein_agent.py. - Autonomy bounds align with Llm Authority. - Decision locality aligns with Execution Model. - Failure and recovery align with Invariants. - Non-orchestration aligns with Execution Lifecycle.  </p>"},{"location":"research/agentic_criteria/#invariants","title":"Invariants","text":"<p>Criteria remain consistent across releases. Criteria align with Core. Criteria checks align with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"research/agentic_criteria/#failure-modes","title":"Failure Modes","text":"<p>Missing evidence breaks this checklist. Drift in criteria breaks Core. Unlinked evidence breaks Docs Style.  </p>"},{"location":"research/agentic_criteria/#extension-points","title":"Extension Points","text":"<p>Criteria updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/agentic_criteria/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when criteria are encoded. The replacement is Invariants. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_protein_agent.py.  </p>"},{"location":"research/decisive_experiment/","title":"decisive_experiment","text":"<p>Scope: Decisive experiment design. Audience: Reviewers and contributors. Guarantees: Experiment is interpretable. Non-Goals: Full protocol. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/decisive_experiment/#overview","title":"Overview","text":"<p>This doc defines one decisive experiment. Architecture context lives in Architecture. Claim context lives in Falsifiable Claim.  </p>"},{"location":"research/decisive_experiment/#contracts","title":"Contracts","text":"<p>Experiment compares recovery rate with and without regulator proposals. Metrics follow Metrics. The experiment uses deterministic replay from Execution Model. Evidence uses tests/regression/test_negative_results.py.  </p>"},{"location":"research/decisive_experiment/#invariants","title":"Invariants","text":"<p>Experiment inputs remain fixed. Experiment aligns with Core. Evidence aligns with tests/regression/test_negative_results.py.  </p>"},{"location":"research/decisive_experiment/#failure-modes","title":"Failure Modes","text":"<p>Missing controls breaks interpretation. Drift in setup breaks Falsifiable Claim. Missing evidence breaks Docs Style.  </p>"},{"location":"research/decisive_experiment/#extension-points","title":"Extension Points","text":"<p>Experiment updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/decisive_experiment/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when an experiment suite exists. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_negative_results.py.  </p>"},{"location":"research/falsifiable_claim/","title":"falsifiable_claim","text":"<p>Scope: Single falsifiable claim. Audience: Reviewers and contributors. Guarantees: Claim is testable. Non-Goals: Multiple hypotheses. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/falsifiable_claim/#overview","title":"Overview","text":"<p>This doc states one falsifiable claim. Architecture context lives in Architecture. Vocabulary aligns with Core Concepts.  </p>"},{"location":"research/falsifiable_claim/#contracts","title":"Contracts","text":"<p>Claim: bounded regulator proposals improve recovery rate without raising failure rate. Recovery rate is computed in Metrics. Failure rate is computed in Metrics. Evidence uses tests/regression/test_negative_results.py.  </p>"},{"location":"research/falsifiable_claim/#invariants","title":"Invariants","text":"<p>Claim wording stays fixed. Claim aligns with Core. Evidence aligns with tests/regression/test_negative_results.py.  </p>"},{"location":"research/falsifiable_claim/#failure-modes","title":"Failure Modes","text":"<p>Unclear claim blocks experiments. Claim drift breaks Core. Missing evidence breaks Docs Style.  </p>"},{"location":"research/falsifiable_claim/#extension-points","title":"Extension Points","text":"<p>Claim updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/falsifiable_claim/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when claim is replaced. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_negative_results.py.  </p>"},{"location":"research/formal_model/","title":"formal_model","text":"<p>Scope: Minimal formal model. Audience: Reviewers and contributors. Guarantees: State and constraint sets are explicit. Non-Goals: Full proofs. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/formal_model/#overview","title":"Overview","text":"<p>This doc defines a minimal formal model. Architecture context lives in Architecture. Vocabulary aligns with Core Concepts.  </p>"},{"location":"research/formal_model/#contracts","title":"Contracts","text":"<p>State space S is the set of agent states. Action space A is the set of signals. Transition function T maps (S, A) to S. Constraint set C limits valid transitions. Constraints align with Invariants. Validation uses tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/formal_model/#invariants","title":"Invariants","text":"<p>S, A, T, and C remain consistent. Definitions align with Core. Evidence aligns with tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/formal_model/#failure-modes","title":"Failure Modes","text":"<p>Ambiguous symbols break reviewability. Drift in definitions breaks Core. Unlinked references break Docs Style.  </p>"},{"location":"research/formal_model/#extension-points","title":"Extension Points","text":"<p>Model updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/formal_model/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when a formal spec exists. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/neutral_results/","title":"neutral_results","text":"<p>Scope: Negative and neutral results. Audience: Reviewers and contributors. Guarantees: Limits are documented. Non-Goals: Full benchmark report. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/neutral_results/#overview","title":"Overview","text":"<p>This doc records neutral and negative results. Architecture context lives in Architecture. Claim context lives in Falsifiable Claim.  </p>"},{"location":"research/neutral_results/#contracts","title":"Contracts","text":"<p>Regulator proposals can reduce recovery under strict constraints. Agenticity adds no benefit in low-noise pathways. Deterministic baselines win in short runs. Evidence uses tests/regression/test_negative_results.py.  </p>"},{"location":"research/neutral_results/#invariants","title":"Invariants","text":"<p>Reported negatives remain visible. Results align with Core. Evidence aligns with tests/regression/test_negative_results.py.  </p>"},{"location":"research/neutral_results/#failure-modes","title":"Failure Modes","text":"<p>Missing negatives reduces credibility. Result drift breaks Core. Missing evidence breaks Docs Style.  </p>"},{"location":"research/neutral_results/#extension-points","title":"Extension Points","text":"<p>Result updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/neutral_results/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when results are automated. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_negative_results.py.  </p>"},{"location":"research/reviewer_premortem/","title":"reviewer_premortem","text":"<p>Scope: Reviewer pre-mortem. Audience: Reviewers and contributors. Guarantees: Anticipated critiques are explicit. Non-Goals: Debate. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/reviewer_premortem/#overview","title":"Overview","text":"<p>This doc lists common review critiques. Architecture context lives in Architecture. Claim context lives in Falsifiable Claim.  </p>"},{"location":"research/reviewer_premortem/#contracts","title":"Contracts","text":"<p>Critique: \u201cThis is orchestration.\u201d Response: signal scopes and pathway contracts show locality. Critique: \u201cNo intelligence.\u201d Response: regulator proposals are bounded and measured. Critique: \u201cBiology metaphor.\u201d Response: constrained agents and pathways are explicit. Critique: \u201cOver-engineered.\u201d Response: invariants and failures are enforced. Evidence uses tests/regression/test_architecture_invariants.py.  </p>"},{"location":"research/reviewer_premortem/#invariants","title":"Invariants","text":"<p>Critique list stays visible. Responses align with Core. Evidence aligns with tests/regression/test_architecture_invariants.py.  </p>"},{"location":"research/reviewer_premortem/#failure-modes","title":"Failure Modes","text":"<p>Missing critiques weakens review readiness. Response drift breaks Core. Missing evidence breaks Docs Style.  </p>"},{"location":"research/reviewer_premortem/#extension-points","title":"Extension Points","text":"<p>Updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/reviewer_premortem/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when critiques are encoded. The replacement is Metrics. Obsolete docs are removed.  </p> <p>Code refs: tests/regression/test_architecture_invariants.py.  </p>"},{"location":"research/system_schematic/","title":"system_schematic","text":"<p>Scope: One-page system schematic. Audience: Reviewers and contributors. Guarantees: Components and boundaries are explicit. Non-Goals: Full architecture narrative. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"research/system_schematic/#overview","title":"Overview","text":"<p>This doc provides a single schematic. Architecture context lives in Architecture. Vocabulary aligns with Core Concepts.  </p>"},{"location":"research/system_schematic/#contracts","title":"Contracts","text":"<p>Agents exchange signals within pathway edges. Constraints gate transitions and outputs. Regulator proposals remain bounded. Evidence uses tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/system_schematic/#invariants","title":"Invariants","text":"<p>Schematic elements stay aligned with Core. Boundaries align with Llm Authority. Evidence aligns with tests/unit/test_protein_system_rigidity.py.  </p>"},{"location":"research/system_schematic/#failure-modes","title":"Failure Modes","text":"<p>Missing boundary labels weakens reviewability. Diagram drift breaks Core. Missing evidence breaks Docs Style.  </p>"},{"location":"research/system_schematic/#extension-points","title":"Extension Points","text":"<p>Schematic updates follow Docs Style. Extensions align with Experimental. Evidence updates align with tests/unit/test_docs_contract.py.  </p>"},{"location":"research/system_schematic/#exit-criteria","title":"Exit Criteria","text":"<p>This doc is obsolete when diagrams are generated. The replacement is Architecture. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_protein_system_rigidity.py.  </p> <pre><code>flowchart LR\n  AgentA --&gt;|signal| AgentB\n  AgentB --&gt;|signal| AgentC\n  Regulator -.-&gt;|proposal| AgentA\n  Constraints --&gt; AgentA\n  Constraints --&gt; AgentB\n  Failure --&gt; AgentC\n</code></pre>"},{"location":"security/citation/","title":"citation","text":"<p>Scope: Citation metadata and release citation artifacts. Audience: Contributors and release operators. Guarantees: <code>CITATION.cff</code> matches the release version and repository URL. Non-Goals: Reference manager tutorials. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"security/citation/#overview","title":"Overview","text":"<p>This doc defines the citation surface for releases. Canonical metadata lives in CITATION.cff. Citation artifacts are generated via makefiles/citation.mk.  </p>"},{"location":"security/citation/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/unit/test_docs_contract.py. Contracts link to Threat Model and Dependencies. - <code>CITATION.cff</code> is the canonical source of citation metadata. - <code>make citation</code> validates CFF and produces the other formats. - Release tags align with <code>CITATION.cff</code> version values.  </p>"},{"location":"security/citation/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with scripts/check_changelog_version.py. Invariants align with Dependencies. - Citation metadata uses the repository URL and SPDX license. - Authors list includes the canonical ORCID record. - Citation artifacts stay in sync with <code>CITATION.cff</code>.  </p>"},{"location":"security/citation/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/unit/test_docs_contract.py. Failures align with Docs Style. - Release metadata drift triggers a CI failure. - Missing citation files block release publishing. - Invalid CFF schema fails validation.  </p>"},{"location":"security/citation/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Dependencies. Extensions align with scripts/check_changelog_version.py. - New citation formats require updates to <code>makefiles/citation.mk</code>. - New metadata fields require <code>CITATION.cff</code> changes.  </p>"},{"location":"security/citation/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when citation artifacts are generated elsewhere. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_docs_contract.py.  </p>"},{"location":"security/dependencies/","title":"dependencies","text":"<p>Scope: Runtime dependency allowlist. Audience: Contributors and reviewers. Guarantees: Allowlist covers project.dependencies. Non-Goals: Dev dependency tracking. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"security/dependencies/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Threat Model before edits. Read Docs Style for context.  </p>"},{"location":"security/dependencies/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with scripts/check_dependency_allowlist.py. Contracts link to Threat Model and Docs Style.  </p>"},{"location":"security/dependencies/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with scripts/check_dependency_allowlist.py. Invariants align with Threat Model.  </p>"},{"location":"security/dependencies/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with scripts/check_dependency_allowlist.py. Failures align with Docs Style.  </p>"},{"location":"security/dependencies/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Threat Model. Extensions align with scripts/check_dependency_allowlist.py.  </p>"},{"location":"security/dependencies/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: scripts/check_dependency_allowlist.py. Allowlist: - requests - biopython - numpy - click - fastapi - uvicorn - pydantic - loguru - slowapi - boto3  </p>"},{"location":"security/threat_model/","title":"threat_model","text":"<p>Scope: Threat model skeleton. Audience: Contributors. Guarantees: Captures abuse cases, resource risks, and assumptions. Non-Goals: Mitigations. Why: This doc exists to record its single responsibility for review.  </p>"},{"location":"security/threat_model/#overview","title":"Overview","text":"<p>This doc defines one responsibility. Architecture components are defined in Architecture. Read Dependencies before edits. Read Docs Style for context.  </p>"},{"location":"security/threat_model/#contracts","title":"Contracts","text":"<p>Each statement is a contract. Contracts align with tests/unit/test_abuse_case_path_traversal.py. Contracts link to Dependencies and Docs Style.  </p>"},{"location":"security/threat_model/#invariants","title":"Invariants","text":"<p>Invariants describe stable behavior. Checks align with tests/unit/test_abuse_case_path_traversal.py. Invariants align with Dependencies.  </p>"},{"location":"security/threat_model/#failure-modes","title":"Failure Modes","text":"<p>Failures are explicit and tested. Failure coverage aligns with tests/unit/test_abuse_case_path_traversal.py. Failures align with Docs Style.  </p>"},{"location":"security/threat_model/#extension-points","title":"Extension Points","text":"<p>Extensions require tests and docs. Extensions are tracked in Dependencies. Extensions align with tests/unit/test_abuse_case_path_traversal.py.  </p>"},{"location":"security/threat_model/#exit-criteria","title":"Exit Criteria","text":"<p>This doc becomes obsolete when the surface ends. The replacement is linked in Docs Style. Obsolete docs are removed.  </p> <p>Code refs: tests/unit/test_abuse_case_path_traversal.py. Threats: - Conceptual drift in core definitions. - LLM overreach beyond regulator bounds. - Performance regression under load. - Reviewer misinterpretation of claims. Abuse cases: - Path traversal via candidate IDs. - Crafted sequence inputs to bypass validation. - Unauthorized resume requests for stale runs. Resource risks: - Large batch runs exhaust disk. - Oversized sequences exhaust memory. - High-rate API requests saturate CPU. Assumptions: - Local filesystem permissions prevent cross-tenant access. - Providers return deterministic results for fixed inputs. - CI artifacts are not tampered with between steps.  </p>"}]}